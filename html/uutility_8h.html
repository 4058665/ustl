<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>uutility.h File Reference</title>
    <link href="../style/default.css" rel="stylesheet" type="text/css" />
    <link href="../style/ustlstyle.css" rel="stylesheet" type="text/css" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="API and usage description for uSTL, a size-optimized STL implementation" />
    <meta name="Keywords" content="C++, STL, template, bloat, optimization" />
</head>
<body>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">uutility.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility templates.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;utypes.h&quot;</code><br/>
<code>#include &quot;traits.h&quot;</code><br/>
<code>#include &quot;ulimits.h&quot;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceustl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html">ustl</a></td></tr>
<tr class="memdesc:namespaceustl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ustl namespace contains all ustl classes and algorithms. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1e713d3c4a1de5b99a005eac036f42de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e713d3c4a1de5b99a005eac036f42de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#a1e713d3c4a1de5b99a005eac036f42de">VectorSize</a>(v)&#160;&#160;&#160;(sizeof(v) / sizeof(*v))</td></tr>
<tr class="memdesc:a1e713d3c4a1de5b99a005eac036f42de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a static vector. <br/></td></tr>
<tr class="separator:a1e713d3c4a1de5b99a005eac036f42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed07c9262b5f8b6f8d13fb5cc53feddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed07c9262b5f8b6f8d13fb5cc53feddb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#aed07c9262b5f8b6f8d13fb5cc53feddb">VectorBlock</a>(v)&#160;&#160;&#160;&amp;(v)[0], <a class="el" href="uutility_8h.html#a1e713d3c4a1de5b99a005eac036f42de">VectorSize</a>(v)</td></tr>
<tr class="memdesc:aed07c9262b5f8b6f8d13fb5cc53feddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands into a ptr,size expression for the given static vector; useful as link arguments. <br/></td></tr>
<tr class="separator:aed07c9262b5f8b6f8d13fb5cc53feddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0cf7b04a9538beb7cbcb697bbd046b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec0cf7b04a9538beb7cbcb697bbd046b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#aec0cf7b04a9538beb7cbcb697bbd046b">VectorRange</a>(v)&#160;&#160;&#160;&amp;(v)[0], VectorEnd(v)</td></tr>
<tr class="memdesc:aec0cf7b04a9538beb7cbcb697bbd046b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands into a begin,end expression for the given static vector; useful for algorithm arguments. <br/></td></tr>
<tr class="separator:aec0cf7b04a9538beb7cbcb697bbd046b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba1ede6ce131203d657d4afc0665f6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ba1ede6ce131203d657d4afc0665f6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#a6ba1ede6ce131203d657d4afc0665f6a">BitsInType</a>(t)&#160;&#160;&#160;(sizeof(t) * CHAR_BIT)</td></tr>
<tr class="memdesc:a6ba1ede6ce131203d657d4afc0665f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits in the given type. <br/></td></tr>
<tr class="separator:a6ba1ede6ce131203d657d4afc0665f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3ae12a9f431a9af9d958417d231571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb3ae12a9f431a9af9d958417d231571"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#afb3ae12a9f431a9af9d958417d231571">BitMask</a>(t, n)&#160;&#160;&#160;(t(~t(0)) &gt;&gt; (<a class="el" href="uutility_8h.html#a6ba1ede6ce131203d657d4afc0665f6a">BitsInType</a>(t) - (n)))</td></tr>
<tr class="memdesc:afb3ae12a9f431a9af9d958417d231571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask of type <code>t</code> with the lowest <code>n</code> bits set. <br/></td></tr>
<tr class="separator:afb3ae12a9f431a9af9d958417d231571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea1ac2c70941928e48b7931fc87c811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea1ac2c70941928e48b7931fc87c811"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#a9ea1ac2c70941928e48b7931fc87c811">DebugArg</a>(x)&#160;&#160;&#160;x</td></tr>
<tr class="memdesc:a9ea1ac2c70941928e48b7931fc87c811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument that is used only in debug builds (as in an assert) <br/></td></tr>
<tr class="separator:a9ea1ac2c70941928e48b7931fc87c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e878a5bd9fc55b61bff30bb4b49d70e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e878a5bd9fc55b61bff30bb4b49d70e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#a6e878a5bd9fc55b61bff30bb4b49d70e">foreach</a>(type, i, ctr)&#160;&#160;&#160;for (type i = (ctr).begin(); i != (ctr).end(); ++ i)</td></tr>
<tr class="memdesc:a6e878a5bd9fc55b61bff30bb4b49d70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for container iteration. <br/></td></tr>
<tr class="separator:a6e878a5bd9fc55b61bff30bb4b49d70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969fecac07e3453c78ff5ffb3adc55c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a969fecac07e3453c78ff5ffb3adc55c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#a969fecac07e3453c78ff5ffb3adc55c1">eachfor</a>(type, i, ctr)&#160;&#160;&#160;for (type i = (ctr).rbegin(); i != (ctr).rend(); ++ i)</td></tr>
<tr class="memdesc:a969fecac07e3453c78ff5ffb3adc55c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for container reverse iteration. <br/></td></tr>
<tr class="separator:a969fecac07e3453c78ff5ffb3adc55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6613e3faec4f5e76230be47d47c48362"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6613e3faec4f5e76230be47d47c48362"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uutility_8h.html#a6613e3faec4f5e76230be47d47c48362">ALL_MMX_REGS_CHANGELIST</a>&#160;&#160;&#160;&quot;mm0&quot;,&quot;mm1&quot;,&quot;mm2&quot;,&quot;mm3&quot;,&quot;mm4&quot;,&quot;mm5&quot;,&quot;mm6&quot;,&quot;mm7&quot;,&quot;st&quot;,&quot;st(1)&quot;,&quot;st(2)&quot;,&quot;st(3)&quot;,&quot;st(4)&quot;,&quot;st(5)&quot;,&quot;st(6)&quot;,&quot;st(7)&quot;</td></tr>
<tr class="memdesc:a6613e3faec4f5e76230be47d47c48362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call after you are done using SIMD algorithms for 64 bit tuples. <br/></td></tr>
<tr class="separator:a6613e3faec4f5e76230be47d47c48362"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a682663ec9ec63d569d30fbe55beca2f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a682663ec9ec63d569d30fbe55beca2f9"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a682663ec9ec63d569d30fbe55beca2f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a682663ec9ec63d569d30fbe55beca2f9">ustl::VectorEnd</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:a682663ec9ec63d569d30fbe55beca2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end() for a static vector. <br/></td></tr>
<tr class="separator:a682663ec9ec63d569d30fbe55beca2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e712dd6676c1b2a805c05cc412484f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97e712dd6676c1b2a805c05cc412484f"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a97e712dd6676c1b2a805c05cc412484f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a97e712dd6676c1b2a805c05cc412484f">ustl::min</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a97e712dd6676c1b2a805c05cc412484f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of <code>a</code> and <code>b</code>. <br/></td></tr>
<tr class="separator:a97e712dd6676c1b2a805c05cc412484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c31c98136c275966fbd8e24e23ae1f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c31c98136c275966fbd8e24e23ae1f7"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7c31c98136c275966fbd8e24e23ae1f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a7c31c98136c275966fbd8e24e23ae1f7">ustl::max</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a7c31c98136c275966fbd8e24e23ae1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of <code>a</code> and <code>b</code>. <br/></td></tr>
<tr class="separator:a7c31c98136c275966fbd8e24e23ae1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b10e0f388002924ccc1835082145a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a30b10e0f388002924ccc1835082145a4"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a30b10e0f388002924ccc1835082145a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a30b10e0f388002924ccc1835082145a4">ustl::VectorElement</a> (T(&amp;v)[N], size_t i)</td></tr>
<tr class="memdesc:a30b10e0f388002924ccc1835082145a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexes into a static array with bounds limit. <br/></td></tr>
<tr class="separator:a30b10e0f388002924ccc1835082145a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212837153937180d6a84a3fe07c4f640"><td class="memTemplParams" colspan="2"><a class="anchor" id="a212837153937180d6a84a3fe07c4f640"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a212837153937180d6a84a3fe07c4f640"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a212837153937180d6a84a3fe07c4f640">ustl::AlignDown</a> (T n, size_t grain=c_DefaultAlignment)</td></tr>
<tr class="memdesc:a212837153937180d6a84a3fe07c4f640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds <code>n</code> up to be divisible by <code>grain</code>. <br/></td></tr>
<tr class="separator:a212837153937180d6a84a3fe07c4f640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39742f00eac8232568d7c124097aca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b39742f00eac8232568d7c124097aca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b39742f00eac8232568d7c124097aca"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a9b39742f00eac8232568d7c124097aca">ustl::Align</a> (T n, size_t grain=c_DefaultAlignment)</td></tr>
<tr class="memdesc:a9b39742f00eac8232568d7c124097aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds <code>n</code> up to be divisible by <code>grain</code>. <br/></td></tr>
<tr class="separator:a9b39742f00eac8232568d7c124097aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b6387875022f310d1d128bf25480ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a39b6387875022f310d1d128bf25480ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39b6387875022f310d1d128bf25480ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a39b6387875022f310d1d128bf25480ca">ustl::NullPointer</a> (void)</td></tr>
<tr class="memdesc:a39b6387875022f310d1d128bf25480ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL pointer cast to T. <br/></td></tr>
<tr class="separator:a39b6387875022f310d1d128bf25480ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad818c99105faa4a68f55d519a89db505"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad818c99105faa4a68f55d519a89db505"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad818c99105faa4a68f55d519a89db505"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ad818c99105faa4a68f55d519a89db505">ustl::NullValue</a> (void)</td></tr>
<tr class="memdesc:ad818c99105faa4a68f55d519a89db505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-dereferentiable value reference. This is useful for passing to stream_align_of or the like which need a value but don't need to actually use it. <br/></td></tr>
<tr class="separator:ad818c99105faa4a68f55d519a89db505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082b5d5dcac34db043cd212a6f830ca8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a082b5d5dcac34db043cd212a6f830ca8"></a>
template&lt;typename T , typename Distance &gt; </td></tr>
<tr class="memitem:a082b5d5dcac34db043cd212a6f830ca8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a082b5d5dcac34db043cd212a6f830ca8">ustl::advance</a> (T i, Distance offset)</td></tr>
<tr class="memdesc:a082b5d5dcac34db043cd212a6f830ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets an iterator. <br/></td></tr>
<tr class="separator:a082b5d5dcac34db043cd212a6f830ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f6c55519656f92212f72aec9916c03"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3f6c55519656f92212f72aec9916c03"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa3f6c55519656f92212f72aec9916c03"><td class="memTemplItemLeft" align="right" valign="top">constexpr ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa3f6c55519656f92212f72aec9916c03">ustl::distance</a> (T1 i1, T2 i2)</td></tr>
<tr class="memdesc:aa3f6c55519656f92212f72aec9916c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference <code>p1</code> - <code>p2</code>. <br/></td></tr>
<tr class="separator:aa3f6c55519656f92212f72aec9916c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1cf2ae964870f20ab96c53fcd2a9a0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ae1cf2ae964870f20ab96c53fcd2a9a0e">ustl::absv</a> (T v)</td></tr>
<tr class="memdesc:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of <code>v</code> Unlike the stdlib functions, this is inline and works with all types. <br/></td></tr>
<tr class="separator:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a185ef880ee8ddb99b8789df5ef7ef49f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a185ef880ee8ddb99b8789df5ef7ef49f">ustl::sign</a> (T v)</td></tr>
<tr class="memdesc:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -1 for negative values, 1 for positive, and 0 for 0. <br/></td></tr>
<tr class="separator:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c86fef85e5eaa8fde86a58614099e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d0c86fef85e5eaa8fde86a58614099e"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1d0c86fef85e5eaa8fde86a58614099e"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1d0c86fef85e5eaa8fde86a58614099e">ustl::abs_distance</a> (T1 i1, T2 i2)</td></tr>
<tr class="memdesc:a1d0c86fef85e5eaa8fde86a58614099e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the distance i1 and i2. <br/></td></tr>
<tr class="separator:a1d0c86fef85e5eaa8fde86a58614099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49903aef740bceb8d4ff984de839d9f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49903aef740bceb8d4ff984de839d9f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49903aef740bceb8d4ff984de839d9f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a49903aef740bceb8d4ff984de839d9f3">ustl::size_of_elements</a> (size_t n, const T *)</td></tr>
<tr class="memdesc:a49903aef740bceb8d4ff984de839d9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of <code>n</code> elements of size <code>T</code>. <br/></td></tr>
<tr class="separator:a49903aef740bceb8d4ff984de839d9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011e13fddd1c6c10d703c4b3f8f76809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a011e13fddd1c6c10d703c4b3f8f76809"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>ustl::bswap_16</b> (uint16_t v)</td></tr>
<tr class="separator:a011e13fddd1c6c10d703c4b3f8f76809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c4ec5b3ba9d6946187ee7a88862f1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82c4ec5b3ba9d6946187ee7a88862f1e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ustl::bswap_32</b> (uint32_t v)</td></tr>
<tr class="separator:a82c4ec5b3ba9d6946187ee7a88862f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf45476dd30b40810240775c9b1c656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbf45476dd30b40810240775c9b1c656"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>ustl::bswap_64</b> (uint64_t v)</td></tr>
<tr class="separator:afbf45476dd30b40810240775c9b1c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb8996e66254e65468eae028c8f599"><td class="memTemplParams" colspan="2"><a class="anchor" id="acccb8996e66254e65468eae028c8f599"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acccb8996e66254e65468eae028c8f599"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#acccb8996e66254e65468eae028c8f599">ustl::bswap</a> (const T &amp;v)</td></tr>
<tr class="memdesc:acccb8996e66254e65468eae028c8f599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byteorder of <code>v</code>. <br/></td></tr>
<tr class="separator:acccb8996e66254e65468eae028c8f599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc02774aa67eb470e3da31243c03c8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44bc02774aa67eb470e3da31243c03c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44bc02774aa67eb470e3da31243c03c8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ustl::le_to_native</b> (const T &amp;v)</td></tr>
<tr class="separator:a44bc02774aa67eb470e3da31243c03c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dec89857583920ea685a7d776b6145"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98dec89857583920ea685a7d776b6145"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98dec89857583920ea685a7d776b6145"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ustl::be_to_native</b> (const T &amp;v)</td></tr>
<tr class="separator:a98dec89857583920ea685a7d776b6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd520bcceef5c0d2d24180accc963e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6cd520bcceef5c0d2d24180accc963e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd520bcceef5c0d2d24180accc963e7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ustl::native_to_le</b> (const T &amp;v)</td></tr>
<tr class="separator:a6cd520bcceef5c0d2d24180accc963e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb86deacdf9d2d01df702dc8b5961208"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb86deacdf9d2d01df702dc8b5961208"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb86deacdf9d2d01df702dc8b5961208"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ustl::native_to_be</b> (const T &amp;v)</td></tr>
<tr class="separator:adb86deacdf9d2d01df702dc8b5961208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa36c7bb72d2ee3590f26f8dd3c9b8b6a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa36c7bb72d2ee3590f26f8dd3c9b8b6a">ustl::Delete</a> (T *&amp;p)</td></tr>
<tr class="memdesc:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>p</code> and sets it to NULL. <br/></td></tr>
<tr class="separator:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689f2db55308f0b38467e3d4c251ca8a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a689f2db55308f0b38467e3d4c251ca8a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a689f2db55308f0b38467e3d4c251ca8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a689f2db55308f0b38467e3d4c251ca8a">ustl::DeleteVector</a> (T *&amp;p)</td></tr>
<tr class="memdesc:a689f2db55308f0b38467e3d4c251ca8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>p</code> as an array and sets it to NULL. <br/></td></tr>
<tr class="separator:a689f2db55308f0b38467e3d4c251ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9188c144f6085dc6bf05b69b9c3a11b8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a9188c144f6085dc6bf05b69b9c3a11b8">ustl::operator!=</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making != from ! and ==. <br/></td></tr>
<tr class="separator:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c8fa4b3b83567aa2c94df6a8d99b917"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a2c8fa4b3b83567aa2c94df6a8d99b917">ustl::operator&gt;</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making &gt; from &lt;. <br/></td></tr>
<tr class="separator:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4e357df8e58961b3f17181089e8f73"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b4e357df8e58961b3f17181089e8f73"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b4e357df8e58961b3f17181089e8f73"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1b4e357df8e58961b3f17181089e8f73">ustl::operator&lt;=</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a1b4e357df8e58961b3f17181089e8f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making &lt;= from &lt; and ==. <br/></td></tr>
<tr class="separator:a1b4e357df8e58961b3f17181089e8f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e06d2408bfd0dfef28bb8595445689"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29e06d2408bfd0dfef28bb8595445689"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29e06d2408bfd0dfef28bb8595445689"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a29e06d2408bfd0dfef28bb8595445689">ustl::operator&gt;=</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a29e06d2408bfd0dfef28bb8595445689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making &gt;= from &lt; and ==. <br/></td></tr>
<tr class="separator:a29e06d2408bfd0dfef28bb8595445689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be96ec90ba71c75bd3e74ee7be0789"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68be96ec90ba71c75bd3e74ee7be0789"></a>
template&lt;typename TSmall , typename TBig &gt; </td></tr>
<tr class="memitem:a68be96ec90ba71c75bd3e74ee7be0789"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a68be96ec90ba71c75bd3e74ee7be0789">ustl::pack_type</a> (TSmall s, TBig &amp;b)</td></tr>
<tr class="memdesc:a68be96ec90ba71c75bd3e74ee7be0789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs <code>s</code> multiple times into <code>b</code>. Useful for loop unrolling. <br/></td></tr>
<tr class="separator:a68be96ec90ba71c75bd3e74ee7be0789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e8e74e1e3038d1c8a590d0470087a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04e8e74e1e3038d1c8a590d0470087a9"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a04e8e74e1e3038d1c8a590d0470087a9"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a04e8e74e1e3038d1c8a590d0470087a9">ustl::DivRU</a> (T1 n1, T2 n2)</td></tr>
<tr class="memdesc:a04e8e74e1e3038d1c8a590d0470087a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>n1</code> by <code>n2</code> and rounds the result up. This is in contrast to regular division, which rounds down. <br/></td></tr>
<tr class="separator:a04e8e74e1e3038d1c8a590d0470087a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaa1a42d5fe2c94be68a65629069449"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eaa1a42d5fe2c94be68a65629069449"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a5eaa1a42d5fe2c94be68a65629069449">ustl::TestAndSet</a> (int *pm)</td></tr>
<tr class="memdesc:a5eaa1a42d5fe2c94be68a65629069449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contents of <code>pm</code> to 1 and returns true if the previous value was 0. <br/></td></tr>
<tr class="separator:a5eaa1a42d5fe2c94be68a65629069449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1684fbc1aa083aab0bbc4c4978b7b3b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1684fbc1aa083aab0bbc4c4978b7b3b5"></a>
uoff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1684fbc1aa083aab0bbc4c4978b7b3b5">ustl::FirstBit</a> (uint32_t v, uoff_t nbv)</td></tr>
<tr class="memdesc:a1684fbc1aa083aab0bbc4c4978b7b3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in <code>v</code> or <code>nbv</code> if none. <br/></td></tr>
<tr class="separator:a1684fbc1aa083aab0bbc4c4978b7b3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85ebb56453778aaebdcfc1c26879ddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa85ebb56453778aaebdcfc1c26879ddc"></a>
uoff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa85ebb56453778aaebdcfc1c26879ddc">ustl::FirstBit</a> (uint64_t v, uoff_t nbv)</td></tr>
<tr class="memdesc:aa85ebb56453778aaebdcfc1c26879ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in <code>v</code> or <code>nbv</code> if none. <br/></td></tr>
<tr class="separator:aa85ebb56453778aaebdcfc1c26879ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8cf73394e5fbf1b6b03de315334403"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#abb8cf73394e5fbf1b6b03de315334403">ustl::NextPow2</a> (uint32_t v)</td></tr>
<tr class="separator:abb8cf73394e5fbf1b6b03de315334403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3255777c7527ce6d776aa0f52707a7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3255777c7527ce6d776aa0f52707a7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3255777c7527ce6d776aa0f52707a7a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ac3255777c7527ce6d776aa0f52707a7a">ustl::Rol</a> (T v, size_t n)</td></tr>
<tr class="memdesc:ac3255777c7527ce6d776aa0f52707a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise rotate value left. <br/></td></tr>
<tr class="separator:ac3255777c7527ce6d776aa0f52707a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741af4fabf6753b7cf205e82924e18f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a741af4fabf6753b7cf205e82924e18f4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a741af4fabf6753b7cf205e82924e18f4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a741af4fabf6753b7cf205e82924e18f4">ustl::Ror</a> (T v, size_t n)</td></tr>
<tr class="memdesc:a741af4fabf6753b7cf205e82924e18f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise rotate value right. <br/></td></tr>
<tr class="separator:a741af4fabf6753b7cf205e82924e18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfff1e222dd08016ec1a1f788b2cea8"><td class="memTemplParams" colspan="2">template&lt;typename DEST , typename SRC &gt; </td></tr>
<tr class="memitem:afdfff1e222dd08016ec1a1f788b2cea8"><td class="memTemplItemLeft" align="right" valign="top">DEST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#afdfff1e222dd08016ec1a1f788b2cea8">ustl::noalias</a> (const DEST &amp;, SRC *s)</td></tr>
<tr class="memdesc:afdfff1e222dd08016ec1a1f788b2cea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template is to be used for dereferencing a type-punned pointer without a warning.  <a href="#afdfff1e222dd08016ec1a1f788b2cea8">More...</a><br/></td></tr>
<tr class="separator:afdfff1e222dd08016ec1a1f788b2cea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3504e47b7842e670e5966fc0248c10f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3504e47b7842e670e5966fc0248c10f1"></a>
template&lt;typename DEST , typename SRC &gt; </td></tr>
<tr class="memitem:a3504e47b7842e670e5966fc0248c10f1"><td class="memTemplItemLeft" align="right" valign="top">DEST&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ustl::noalias_cast</b> (SRC s)</td></tr>
<tr class="separator:a3504e47b7842e670e5966fc0248c10f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227045812c5f402e9cb96cae69e42b8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a227045812c5f402e9cb96cae69e42b8f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ustl::simd::reset_mmx</b> (void)</td></tr>
<tr class="separator:a227045812c5f402e9cb96cae69e42b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8a1660fbafffddb5b06253d05b6df760"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a1660fbafffddb5b06253d05b6df760"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a8a1660fbafffddb5b06253d05b6df760">ustl::c_DefaultAlignment</a> = __alignof__(void*)</td></tr>
<tr class="memdesc:a8a1660fbafffddb5b06253d05b6df760"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alignment performed by default. <br/></td></tr>
<tr class="separator:a8a1660fbafffddb5b06253d05b6df760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility templates. </p>
</div></div><!-- contents -->
<hr>
<address style="align: right;">
<small>
    Generated on Tue Jan 21 2014 20:21:00 for uSTL by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.6
</small>
</address>
</body>
</html>
