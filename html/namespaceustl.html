<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>ustl Namespace Reference</title>
    <link href="../style/default.css" rel="stylesheet" type="text/css" />
    <link href="../style/ustlstyle.css" rel="stylesheet" type="text/css" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="API and usage description for uSTL, a size-optimized STL implementation" />
    <meta name="Keywords" content="C++, STL, template, bloat, optimization" />
</head>
<body>
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ustl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The ustl namespace contains all ustl classes and algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceustl_1_1tm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl_1_1tm.html">tm</a></td></tr>
<tr class="memdesc:namespaceustl_1_1tm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogramming tools. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1CBacktrace.html">CBacktrace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the backtrace from the point of construction.  <a href="classustl_1_1CBacktrace.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1cmemlink.html">cmemlink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-only pointer to a sized block of memory.  <a href="classustl_1_1cmemlink.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1fstream.html">fstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements file operations.  <a href="classustl_1_1fstream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1memblock.html">memblock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated memory block.  <a href="classustl_1_1memblock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1memlink.html">memlink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for pointer to block with size.  <a href="classustl_1_1memlink.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1istream.html">istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to read packed binary streams.  <a href="classustl_1_1istream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1istream__iterator.html">istream_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over an istream to use with uSTL algorithms.  <a href="classustl_1_1istream__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__reader.html">object_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1integral__object__reader.html">integral_object_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1ostream.html">ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to write packed binary streams.  <a href="classustl_1_1ostream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1ostream__iterator.html">ostream_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over an ostream to use with uSTL algorithms.  <a href="classustl_1_1ostream__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__writer.html">object_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1integral__object__writer.html">integral_object_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1ofstream.html">ofstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string stream that writes to an fd. Implements cout and cerr.  <a href="classustl_1_1ofstream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1ifstream.html">ifstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string stream that reads from an fd. Implements cin.  <a href="classustl_1_1ifstream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1istringstream.html">istringstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream that reads textual data from a memory block.  <a href="classustl_1_1istringstream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__text__reader.html">object_text_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1integral__text__object__reader.html">integral_text_object_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__text__reader_3_01string_01_4.html">object_text_reader&lt; string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stream writes textual data into a memory block.  <a href="classustl_1_1ostringstream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__text__writer.html">object_text_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1integral__text__object__writer.html">integral_text_object_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__text__writer_3_01string_01_4.html">object_text_writer&lt; string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1integral__text__object__writer_3_01T_01_5_01_4.html">integral_text_object_writer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__stream__size.html">object_stream_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For partial specialization of stream_size_of for objects.  <a href="structustl_1_1object__stream__size.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1integral__object__stream__size.html">integral_object_stream_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitset is a fixed-size block of memory with addressable bits.  <a href="classustl_1_1bitset.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1exception.html">exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for exceptions, equivalent to std::exception.  <a href="classustl_1_1exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1bad__cast.html">bad_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate a bad dynamic_cast usage.  <a href="classustl_1_1bad__cast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1bad__typeid.html">bad_typeid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1libc__exception.html">libc_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a libc function returns an error.  <a href="classustl_1_1libc__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1file__exception.html">file_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">File-related exceptions.  <a href="classustl_1_1file__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1stream__bounds__exception.html">stream_bounds_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream bounds checking.  <a href="classustl_1_1stream__bounds__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1void__function.html">void_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">void-returning function abstract interface.  <a href="structustl_1_1void__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1unary__function.html">unary_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Result</code> f (<code>Arg</code>) function abstract interface.  <a href="structustl_1_1unary__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1binary__function.html">binary_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Result</code> f (<code>Arg1</code>, <code>Arg2</code>) function abstract interface.  <a href="structustl_1_1binary__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1project1st.html">project1st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects and returns the first argument.  <a href="structustl_1_1project1st.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1project2nd.html">project2nd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects and returns the second argument.  <a href="structustl_1_1project2nd.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1pointer__to__unary__function.html">pointer_to_unary_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper object for unary function pointers. Use the ptr_fun accessor to create this object.  <a href="classustl_1_1pointer__to__unary__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1pointer__to__binary__function.html">pointer_to_binary_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper object for binary function pointers. Use the ptr_fun accessor to create this object.  <a href="classustl_1_1pointer__to__binary__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1unary__negate.html">unary_negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a unary function to return its logical negative. Use the unary_negator accessor to create this object.  <a href="classustl_1_1unary__negate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1binder1st.html">binder1st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a binary function to a unary function by binding a constant value to the first argument. Use the bind1st accessor to create this object.  <a href="classustl_1_1binder1st.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1binder2nd.html">binder2nd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a binary function to a unary function by binding a constant value to the second argument. Use the bind2nd accessor to create this object.  <a href="classustl_1_1binder2nd.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1unary__compose.html">unary_compose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains two unary functions together.  <a href="classustl_1_1unary__compose.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1binary__compose.html">binary_compose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains two unary functions through a binary function.  <a href="classustl_1_1binary__compose.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1priority__queue.html">priority_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorted queue adapter to uSTL containers.  <a href="classustl_1_1priority__queue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1ios__base.html">ios_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines types and constants used by all stream classes.  <a href="classustl_1_1ios__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1ios.html">ios</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the type traits of <code>Iterator</code>.  <a href="structustl_1_1iterator__traits.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>Iterator</code> to behave in an exactly opposite manner.  <a href="classustl_1_1reverse__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1insert__iterator.html">insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls insert on bound container for each assignment.  <a href="classustl_1_1insert__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1back__insert__iterator.html">back_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls push_back on bound container for each assignment.  <a href="classustl_1_1back__insert__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1index__iterate.html">index_iterate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows iteration through an index container.  <a href="classustl_1_1index__iterate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines numeric limits for a type.  <a href="structustl_1_1numeric__limits.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1list.html">list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list, defined as an alias to vector.  <a href="classustl_1_1list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1pair__compare__first.html">pair_compare_first</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1pair__compare__first__key.html">pair_compare_first_key</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1map.html">map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sorted associative container of pair&lt;K,V&gt;  <a href="classustl_1_1map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A two-dimensional array of NX*NY elements of type T.  <a href="classustl_1_1matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1auto__ptr.html">auto_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer.  <a href="classustl_1_1auto__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1Sdtorsr.html">Sdtorsr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1Sdtorsr_3_01T_00_01true_01_4.html">Sdtorsr&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1multimap.html">multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sorted associative container that may container multiple entries for each key.  <a href="classustl_1_1multimap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1multiset.html">multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple sorted container. Unlike set, it may contain multiple copies of each element.  <a href="classustl_1_1multiset.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for two values.  <a href="classustl_1_1pair.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1queue.html">queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue adapter to uSTL containers.  <a href="classustl_1_1queue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1set.html">set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique sorted container. Sorted vector with all values unique.  <a href="classustl_1_1set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1object__stream__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html">object_stream_size&lt; pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the written size of the object.  <a href="structustl_1_1object__stream__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1select1st.html">select1st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a pair and returns pair.first This is an extension, available in uSTL and the SGI STL.  <a href="structustl_1_1select1st.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1select2nd.html">select2nd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a pair and returns pair.second This is an extension, available in uSTL and the SGI STL.  <a href="structustl_1_1select2nd.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustl_1_1numeric__limits_3_01tuple_3_01N_00_01T_01_4_01_4.html">numeric_limits&lt; tuple&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1__long4grain.html">_long4grain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack adapter to uSTL containers.  <a href="classustl_1_1stack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1error__message.html">error_message</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logic errors represent problems in the internal logic of the program.  <a href="classustl_1_1logic__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1domain__error.html">domain_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports domain errors ("domain" is in the mathematical sense)  <a href="classustl_1_1domain__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1invalid__argument.html">invalid_argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports an invalid argument to a function.  <a href="classustl_1_1invalid__argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1length__error.html">length_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports when an object exceeds its allowed size.  <a href="classustl_1_1length__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1out__of__range.html">out_of_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports arguments with values out of allowed range.  <a href="classustl_1_1out__of__range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1runtime__error.html">runtime_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports errors that are dependent on the data being processed.  <a href="classustl_1_1runtime__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1range__error.html">range_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports data that does not fall within the permitted range.  <a href="classustl_1_1range__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1overflow__error.html">overflow_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports arithmetic overflow.  <a href="classustl_1_1overflow__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1underflow__error.html">underflow_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports arithmetic underflow.  <a href="classustl_1_1underflow__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1string.html">string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL basic_string&lt;char&gt; equivalent.  <a href="classustl_1_1string.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1utf8in__iterator.html">utf8in_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator adaptor to character containers for reading UTF-8 encoded text.  <a href="classustl_1_1utf8in__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1utf8out__iterator.html">utf8out_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator adaptor to character containers for writing UTF-8 encoded text.  <a href="classustl_1_1utf8out__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size array of <code>N</code> <code>Ts</code>.  <a href="classustl_1_1tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustl_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL vector equivalent.  <a href="classustl_1_1vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a88f9354681ab7cec0cf1a9cedf30c19d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f9354681ab7cec0cf1a9cedf30c19d"></a>
typedef <a class="el" href="classustl_1_1istream__iterator.html">istream_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceustl.html#a2ecd67ff93cb83383b2c09160bd446f2">utf8subchar_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>istream_iterator_for_utf8</b></td></tr>
<tr class="separator:a88f9354681ab7cec0cf1a9cedf30c19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f1360d674dd4f2f9ba5011afc3e515"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0f1360d674dd4f2f9ba5011afc3e515"></a>
typedef <a class="el" href="classustl_1_1utf8in__iterator.html">utf8in_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classustl_1_1istream__iterator.html">istream_iterator_for_utf8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>utf8istream_iterator</b></td></tr>
<tr class="separator:ae0f1360d674dd4f2f9ba5011afc3e515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48866abd8410c06ded49cbe8e3f43a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48866abd8410c06ded49cbe8e3f43a46"></a>
typedef <a class="el" href="classustl_1_1ostream__iterator.html">ostream_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceustl.html#a2ecd67ff93cb83383b2c09160bd446f2">utf8subchar_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ostream_iterator_for_utf8</b></td></tr>
<tr class="separator:a48866abd8410c06ded49cbe8e3f43a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e393f22a49b0c4e7031a1f0ff31f3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e393f22a49b0c4e7031a1f0ff31f3b"></a>
typedef <a class="el" href="classustl_1_1utf8out__iterator.html">utf8out_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classustl_1_1ostream__iterator.html">ostream_iterator_for_utf8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>utf8ostream_iterator</b></td></tr>
<tr class="separator:a95e393f22a49b0c4e7031a1f0ff31f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c1a201466b6af05c22ef36b79125b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24c1a201466b6af05c22ef36b79125b7"></a>
typedef istringstream::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>issiter_t</b></td></tr>
<tr class="separator:a24c1a201466b6af05c22ef36b79125b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9e6c038ed71e0ddf9012e41a04a175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9e6c038ed71e0ddf9012e41a04a175"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>bitset_value_type</b></td></tr>
<tr class="separator:aca9e6c038ed71e0ddf9012e41a04a175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0c2d8456bc375699b1e319f98dcb65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d0c2d8456bc375699b1e319f98dcb65"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>xfmt_t</b></td></tr>
<tr class="separator:a9d0c2d8456bc375699b1e319f98dcb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcf54d47e873b85c8f98480ca2dcb22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedcf54d47e873b85c8f98480ca2dcb22"></a>
typedef <a class="el" href="classstd_1_1bad__alloc.html">std::bad_alloc</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bad_alloc</b></td></tr>
<tr class="separator:aedcf54d47e873b85c8f98480ca2dcb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecd67ff93cb83383b2c09160bd446f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ecd67ff93cb83383b2c09160bd446f2"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a2ecd67ff93cb83383b2c09160bd446f2">utf8subchar_t</a></td></tr>
<tr class="memdesc:a2ecd67ff93cb83383b2c09160bd446f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for the encoding subcharacters. <br/></td></tr>
<tr class="separator:a2ecd67ff93cb83383b2c09160bd446f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad41d0d7febcb68e2c533b1b2cb93a529"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>xfmt_Exception</b>, 
<br/>
&#160;&#160;<b>xfmt_BadAlloc</b>, 
<br/>
&#160;&#160;<b>xfmt_LibcException</b> = 12, 
<br/>
&#160;&#160;<b>xfmt_FileException</b> = 13, 
<br/>
&#160;&#160;<b>xfmt_StreamBoundsException</b> = 14
<br/>
 }</td></tr>
<tr class="separator:ad41d0d7febcb68e2c533b1b2cb93a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0496a1585f0b895fb74c8f46980e48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>xfmt_ErrorMessage</b> = 2, 
<br/>
&#160;&#160;<b>xfmt_LogicError</b> = xfmt_ErrorMessage, 
<br/>
&#160;&#160;<b>xfmt_RuntimeError</b> = xfmt_ErrorMessage
<br/>
 }</td></tr>
<tr class="separator:abf0496a1585f0b895fb74c8f46980e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5746d21f8010982d4b18d7d19f89992c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5746d21f8010982d4b18d7d19f89992c"></a>
template&lt;typename T , typename Stream &gt; </td></tr>
<tr class="memitem:a5746d21f8010982d4b18d7d19f89992c"><td class="memTemplItemLeft" align="right" valign="top">streamsize&#160;</td><td class="memTemplItemRight" valign="bottom"><b>required_stream_size</b> (T, const Stream &amp;)</td></tr>
<tr class="separator:a5746d21f8010982d4b18d7d19f89992c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7a3ff3aeac9c641d7c4cb0b56bc076"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e7a3ff3aeac9c641d7c4cb0b56bc076"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e7a3ff3aeac9c641d7c4cb0b56bc076"><td class="memTemplItemLeft" align="right" valign="top">streamsize&#160;</td><td class="memTemplItemRight" valign="bottom"><b>required_stream_size</b> (T v, const <a class="el" href="classustl_1_1istream.html">istream</a> &amp;)</td></tr>
<tr class="separator:a7e7a3ff3aeac9c641d7c4cb0b56bc076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd997e0526b276b223364751e792166"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bd997e0526b276b223364751e792166"></a>
template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:a7bd997e0526b276b223364751e792166"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_at_eof</b> (const Stream &amp;stm)</td></tr>
<tr class="separator:a7bd997e0526b276b223364751e792166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f0c2d04919b5c9b94fc2f5af23b315"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8f0c2d04919b5c9b94fc2f5af23b315"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af8f0c2d04919b5c9b94fc2f5af23b315"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_at_eof</b> (const <a class="el" href="classustl_1_1istream.html">istream</a> &amp;)</td></tr>
<tr class="separator:af8f0c2d04919b5c9b94fc2f5af23b315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863d28bcdd08ea58b2ac18a9964e5ba2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a863d28bcdd08ea58b2ac18a9964e5ba2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a863d28bcdd08ea58b2ac18a9964e5ba2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1istream.html">istream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classustl_1_1istream.html">istream</a> &amp;is, T &amp;v)</td></tr>
<tr class="separator:a863d28bcdd08ea58b2ac18a9964e5ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703f247f2d6ac02f14bf7e5e6c3ed90b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a703f247f2d6ac02f14bf7e5e6c3ed90b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a703f247f2d6ac02f14bf7e5e6c3ed90b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1istream.html">istream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classustl_1_1istream.html">istream</a> &amp;is, const T &amp;v)</td></tr>
<tr class="separator:a703f247f2d6ac02f14bf7e5e6c3ed90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841ad034cae5f3095c8681709f5b07a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a841ad034cae5f3095c8681709f5b07a5"></a>
<a class="el" href="classustl_1_1utf8in__iterator.html">utf8istream_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a841ad034cae5f3095c8681709f5b07a5">utf8in</a> (<a class="el" href="classustl_1_1istream.html">istream</a> &amp;is)</td></tr>
<tr class="memdesc:a841ad034cae5f3095c8681709f5b07a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UTF-8 adaptor reading from <code>is</code>. <br/></td></tr>
<tr class="separator:a841ad034cae5f3095c8681709f5b07a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9278bb959ecd1ba6287998a7605d2a11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9278bb959ecd1ba6287998a7605d2a11"></a>
<a class="el" href="classustl_1_1utf8out__iterator.html">utf8ostream_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a9278bb959ecd1ba6287998a7605d2a11">utf8out</a> (<a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;os)</td></tr>
<tr class="memdesc:a9278bb959ecd1ba6287998a7605d2a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UTF-8 adaptor writing to <code>os</code>. <br/></td></tr>
<tr class="separator:a9278bb959ecd1ba6287998a7605d2a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af67b2064c7801da590537d6fbba821"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5af67b2064c7801da590537d6fbba821"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5af67b2064c7801da590537d6fbba821"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;os, const T &amp;v)</td></tr>
<tr class="separator:a5af67b2064c7801da590537d6fbba821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1971bf0353bd23734c9150b4b8103a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2a1971bf0353bd23734c9150b4b8103a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a1971bf0353bd23734c9150b4b8103a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str_to_num</b> (issiter_t i, issiter_t *iend, uint8_t base, T &amp;v)</td></tr>
<tr class="separator:a2a1971bf0353bd23734c9150b4b8103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e36b707501fd7601fe852d8142b06e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83e36b707501fd7601fe852d8142b06e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a83e36b707501fd7601fe852d8142b06e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str_to_num</b> (issiter_t i, issiter_t *iend, uint8_t, double &amp;v)</td></tr>
<tr class="separator:a83e36b707501fd7601fe852d8142b06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579202c9752ddedc91fb4a87be8704a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a579202c9752ddedc91fb4a87be8704a4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a579202c9752ddedc91fb4a87be8704a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str_to_num</b> (issiter_t i, issiter_t *iend, uint8_t base, long long &amp;v)</td></tr>
<tr class="separator:a579202c9752ddedc91fb4a87be8704a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fec08c3348f2a5457e708ca0c914f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4fec08c3348f2a5457e708ca0c914f0"></a>
template&lt;typename RealT , typename CastT &gt; </td></tr>
<tr class="memitem:ab4fec08c3348f2a5457e708ca0c914f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ab4fec08c3348f2a5457e708ca0c914f0">_cast_read</a> (<a class="el" href="classustl_1_1istringstream.html">istringstream</a> &amp;is, RealT &amp;v)</td></tr>
<tr class="memdesc:ab4fec08c3348f2a5457e708ca0c914f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one type as another. <br/></td></tr>
<tr class="separator:ab4fec08c3348f2a5457e708ca0c914f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5a726a8fc7e20de4016df6fca21bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5a726a8fc7e20de4016df6fca21bfb"></a>
<a class="el" href="classustl_1_1istringstream.html">istringstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a0b5a726a8fc7e20de4016df6fca21bfb">getline</a> (<a class="el" href="classustl_1_1istringstream.html">istringstream</a> &amp;is, <a class="el" href="classustl_1_1string.html">string</a> &amp;s)</td></tr>
<tr class="memdesc:a0b5a726a8fc7e20de4016df6fca21bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a line of text from <code>is</code> into <code>s</code>. <br/></td></tr>
<tr class="separator:a0b5a726a8fc7e20de4016df6fca21bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbe5dc3061f2705e8ab5a4e3c389097"><td class="memTemplParams" colspan="2"><a class="anchor" id="afbbe5dc3061f2705e8ab5a4e3c389097"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbbe5dc3061f2705e8ab5a4e3c389097"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1istringstream.html">istringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classustl_1_1istringstream.html">istringstream</a> &amp;is, T &amp;v)</td></tr>
<tr class="separator:afbbe5dc3061f2705e8ab5a4e3c389097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cdd946b496c306dab3454e14066c3e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad4cdd946b496c306dab3454e14066c3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4cdd946b496c306dab3454e14066c3e"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>printf_typestring</b> (const T &amp;)</td></tr>
<tr class="separator:ad4cdd946b496c306dab3454e14066c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e6fde90cfb68988c7a713b26c201fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60e6fde90cfb68988c7a713b26c201fb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60e6fde90cfb68988c7a713b26c201fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const T &amp;v)</td></tr>
<tr class="separator:a60e6fde90cfb68988c7a713b26c201fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20978b997885a2e5ffa4ffddd17ac2e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20978b997885a2e5ffa4ffddd17ac2e5"></a>
<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const char *v)</td></tr>
<tr class="separator:a20978b997885a2e5ffa4ffddd17ac2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c88283bf6b7fea3368c0281c1d454e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74c88283bf6b7fea3368c0281c1d454e"></a>
<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, char *v)</td></tr>
<tr class="separator:a74c88283bf6b7fea3368c0281c1d454e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f9b4edab808e5d5eb83f7ead4bcdf0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18f9b4edab808e5d5eb83f7ead4bcdf0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18f9b4edab808e5d5eb83f7ead4bcdf0"><td class="memTemplItemLeft" align="right" valign="top">streamsize&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a18f9b4edab808e5d5eb83f7ead4bcdf0">stream_size_of</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a18f9b4edab808e5d5eb83f7ead4bcdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given object. Overloads for standard types are available. <br/></td></tr>
<tr class="separator:a18f9b4edab808e5d5eb83f7ead4bcdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af449c6d0ed98a2ae294256843d983444"><td class="memTemplParams" colspan="2"><a class="anchor" id="af449c6d0ed98a2ae294256843d983444"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af449c6d0ed98a2ae294256843d983444"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#af449c6d0ed98a2ae294256843d983444">stream_align_of</a> (const T &amp;)</td></tr>
<tr class="memdesc:af449c6d0ed98a2ae294256843d983444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recommended stream alignment for type <code>T</code>. Override with ALIGNOF. Because this is occasionally called with a null value, do not access the argument! <br/></td></tr>
<tr class="separator:af449c6d0ed98a2ae294256843d983444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d125f2a3632ea26e08bd3cb19c65972"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 &gt; </td></tr>
<tr class="memitem:ga2d125f2a3632ea26e08bd3cb19c65972"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SwapAlgorithms.html#ga2d125f2a3632ea26e08bd3cb19c65972">swap_ranges</a> (ForwardIterator1 first, ForwardIterator2 last, ForwardIterator2 result)</td></tr>
<tr class="separator:ga2d125f2a3632ea26e08bd3cb19c65972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a12f716e46c00f8c3fe3ddf7b44118"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename EqualityComparable &gt; </td></tr>
<tr class="memitem:ga03a12f716e46c00f8c3fe3ddf7b44118"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga03a12f716e46c00f8c3fe3ddf7b44118">find</a> (InputIterator first, InputIterator last, const EqualityComparable &amp;value)</td></tr>
<tr class="separator:ga03a12f716e46c00f8c3fe3ddf7b44118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79f2c798d61c0bba495c924039b29d25"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga79f2c798d61c0bba495c924039b29d25"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga79f2c798d61c0bba495c924039b29d25">adjacent_find</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:ga79f2c798d61c0bba495c924039b29d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6c1ae891e7676a06aef1eeca7c8145"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ga3b6c1ae891e7676a06aef1eeca7c8145"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; InputIterator, <br class="typebreak"/>
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga3b6c1ae891e7676a06aef1eeca7c8145">mismatch</a> (InputIterator first1, InputIterator last1, InputIterator first2)</td></tr>
<tr class="separator:ga3b6c1ae891e7676a06aef1eeca7c8145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d36a7a82f97106134dc5e79005416c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8d36a7a82f97106134dc5e79005416c4"></a>
template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ga8d36a7a82f97106134dc5e79005416c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga8d36a7a82f97106134dc5e79005416c4">equal</a> (InputIterator first1, InputIterator last1, InputIterator first2)</td></tr>
<tr class="memdesc:ga8d36a7a82f97106134dc5e79005416c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if two ranges are equal. This is an extension, present in uSTL and SGI STL. <br/></td></tr>
<tr class="separator:ga8d36a7a82f97106134dc5e79005416c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7215ebfa66a197fb66a111d74390ffb5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename EqualityComparable &gt; </td></tr>
<tr class="memitem:ga7215ebfa66a197fb66a111d74390ffb5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a> (InputIterator first, InputIterator last, const EqualityComparable &amp;value)</td></tr>
<tr class="separator:ga7215ebfa66a197fb66a111d74390ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4516cd4b2891c8267d0a02a99d6661"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga6a4516cd4b2891c8267d0a02a99d6661"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6a4516cd4b2891c8267d0a02a99d6661">transform</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</td></tr>
<tr class="separator:ga6a4516cd4b2891c8267d0a02a99d6661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9978c496162a53db8e25ca312b75841d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga9978c496162a53db8e25ca312b75841d"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga9978c496162a53db8e25ca312b75841d">transform</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op)</td></tr>
<tr class="separator:ga9978c496162a53db8e25ca312b75841d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27eddf28c0d25e6a6b402688a244e65e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga27eddf28c0d25e6a6b402688a244e65e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga27eddf28c0d25e6a6b402688a244e65e">replace</a> (ForwardIterator first, ForwardIterator last, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:ga27eddf28c0d25e6a6b402688a244e65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2617c97fe6ce25d4601d2f80348fb9c3"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga2617c97fe6ce25d4601d2f80348fb9c3"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga2617c97fe6ce25d4601d2f80348fb9c3">replace_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:ga2617c97fe6ce25d4601d2f80348fb9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf224c7959d539bdcc4f0f098c355eefb"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Generator &gt; </td></tr>
<tr class="memitem:gaf224c7959d539bdcc4f0f098c355eefb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaf224c7959d539bdcc4f0f098c355eefb">generate</a> (ForwardIterator first, ForwardIterator last, Generator gen)</td></tr>
<tr class="separator:gaf224c7959d539bdcc4f0f098c355eefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4453ba28cbfa96e63ad17ffc05190ca"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename Generator &gt; </td></tr>
<tr class="memitem:gae4453ba28cbfa96e63ad17ffc05190ca"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gae4453ba28cbfa96e63ad17ffc05190ca">generate_n</a> (OutputIterator first, size_t n, Generator gen)</td></tr>
<tr class="separator:gae4453ba28cbfa96e63ad17ffc05190ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03630073b49d4b886193dadc5ac5e6c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga03630073b49d4b886193dadc5ac5e6c9"></a>
template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga03630073b49d4b886193dadc5ac5e6c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga03630073b49d4b886193dadc5ac5e6c9">reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="memdesc:ga03630073b49d4b886193dadc5ac5e6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse reverses a range. That is: for every i such that 0 &lt;= i &lt;= (last - first) / 2), it exchanges *(first + i) and *(last - (i + 1)). <br/></td></tr>
<tr class="separator:ga03630073b49d4b886193dadc5ac5e6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257779dd8e2656a31e40faf422ec70ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga257779dd8e2656a31e40faf422ec70ac"></a>
template&lt;typename BidirectionalIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga257779dd8e2656a31e40faf422ec70ac"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga257779dd8e2656a31e40faf422ec70ac">reverse_copy</a> (BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:ga257779dd8e2656a31e40faf422ec70ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses [first,last) and writes it to <code>output</code>. <br/></td></tr>
<tr class="separator:ga257779dd8e2656a31e40faf422ec70ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa28c0eb7cbd2b0665c5974e6d80e361f"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaa28c0eb7cbd2b0665c5974e6d80e361f">rotate</a> (ForwardIterator first, ForwardIterator middle, ForwardIterator last)</td></tr>
<tr class="memdesc:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges ranges [first, middle) and [middle, last) <br/></td></tr>
<tr class="separator:gaa28c0eb7cbd2b0665c5974e6d80e361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d55afc9ad4235561be316a99acb441"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83d55afc9ad4235561be316a99acb441"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83d55afc9ad4235561be316a99acb441"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a83d55afc9ad4235561be316a99acb441">rotate</a> (T *first, T *middle, T *last)</td></tr>
<tr class="memdesc:a83d55afc9ad4235561be316a99acb441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointers, which can be treated identically. <br/></td></tr>
<tr class="separator:a83d55afc9ad4235561be316a99acb441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302b1a754f1eccb3434441d410f93866"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga302b1a754f1eccb3434441d410f93866"></a>
template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga302b1a754f1eccb3434441d410f93866"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga302b1a754f1eccb3434441d410f93866">rotate_copy</a> (ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:ga302b1a754f1eccb3434441d410f93866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges ranges [first, middle) and [middle, last) into <code>result</code>. <br/></td></tr>
<tr class="separator:ga302b1a754f1eccb3434441d410f93866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb61aeaee59d94c82c6e8e234dbabf6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7fb61aeaee59d94c82c6e8e234dbabf6"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga7fb61aeaee59d94c82c6e8e234dbabf6"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#ga7fb61aeaee59d94c82c6e8e234dbabf6">merge</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="memdesc:ga7fb61aeaee59d94c82c6e8e234dbabf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two sorted ranges. <br/></td></tr>
<tr class="separator:ga7fb61aeaee59d94c82c6e8e234dbabf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab108bcb2b47ee0fd9e16844548f7e67b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gab108bcb2b47ee0fd9e16844548f7e67b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#gab108bcb2b47ee0fd9e16844548f7e67b">inplace_merge</a> (InputIterator first, InputIterator middle, InputIterator last)</td></tr>
<tr class="separator:gab108bcb2b47ee0fd9e16844548f7e67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a4dc1406ae30880b3d0629ee46851e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga60a4dc1406ae30880b3d0629ee46851e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga60a4dc1406ae30880b3d0629ee46851e">remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)</td></tr>
<tr class="separator:ga60a4dc1406ae30880b3d0629ee46851e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4536237c29c04bd692110d5198099e75"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename RInputIterator &gt; </td></tr>
<tr class="memitem:ga4536237c29c04bd692110d5198099e75"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga4536237c29c04bd692110d5198099e75">remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, RInputIterator rfirst, RInputIterator rlast)</td></tr>
<tr class="separator:ga4536237c29c04bd692110d5198099e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cea777ba522e97ab163e8e3bd6390af"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga6cea777ba522e97ab163e8e3bd6390af"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga6cea777ba522e97ab163e8e3bd6390af">remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="separator:ga6cea777ba522e97ab163e8e3bd6390af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae843d0bdce4ccf55205edb33eb3ba0d0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gae843d0bdce4ccf55205edb33eb3ba0d0"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae843d0bdce4ccf55205edb33eb3ba0d0">unique_copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:gae843d0bdce4ccf55205edb33eb3ba0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692dd0a978c4f31bacc653defaead8f3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga692dd0a978c4f31bacc653defaead8f3"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga692dd0a978c4f31bacc653defaead8f3">unique</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:ga692dd0a978c4f31bacc653defaead8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga721dcc2aef1faf8d2d3d6b5f1799a2ad"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:ga721dcc2aef1faf8d2d3d6b5f1799a2ad"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga721dcc2aef1faf8d2d3d6b5f1799a2ad">lower_bound</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:ga721dcc2aef1faf8d2d3d6b5f1799a2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a948ae544dda7fa055c23873ded9440"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:ga1a948ae544dda7fa055c23873ded9440"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga1a948ae544dda7fa055c23873ded9440">binary_search</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:ga1a948ae544dda7fa055c23873ded9440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ebec40c5bc60a89135ff139ee4b40b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:ga04ebec40c5bc60a89135ff139ee4b40b"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga04ebec40c5bc60a89135ff139ee4b40b">upper_bound</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:ga04ebec40c5bc60a89135ff139ee4b40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabda1bd9e50d171b0e91e4ad0b27e34"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:gafabda1bd9e50d171b0e91e4ad0b27e34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; ForwardIterator, <br class="typebreak"/>
ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#gafabda1bd9e50d171b0e91e4ad0b27e34">equal_range</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:gafabda1bd9e50d171b0e91e4ad0b27e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fcbe75a78ced18f63aa31870f2c3ab9"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga3fcbe75a78ced18f63aa31870f2c3ab9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#ga3fcbe75a78ced18f63aa31870f2c3ab9">random_shuffle</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:ga3fcbe75a78ced18f63aa31870f2c3ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a9591bc6dfcf78b5cdbe129b5a65a54"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5a9591bc6dfcf78b5cdbe129b5a65a54"></a>
template&lt;typename ConstPointer , typename Compare &gt; </td></tr>
<tr class="memitem:ga5a9591bc6dfcf78b5cdbe129b5a65a54"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorObjects.html#ga5a9591bc6dfcf78b5cdbe129b5a65a54">qsort_adapter</a> (const void *p1, const void *p2)</td></tr>
<tr class="memdesc:ga5a9591bc6dfcf78b5cdbe129b5a65a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic compare function adaptor to pass to qsort. <br/></td></tr>
<tr class="separator:ga5a9591bc6dfcf78b5cdbe129b5a65a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab557a24fb30ce4b746af06a983234685"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gab557a24fb30ce4b746af06a983234685"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gab557a24fb30ce4b746af06a983234685">sort</a> (RandomAccessIterator first, RandomAccessIterator last, Compare)</td></tr>
<tr class="separator:gab557a24fb30ce4b746af06a983234685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10efb8df16e5514a4d776b9b847b4732"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga10efb8df16e5514a4d776b9b847b4732"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#ga10efb8df16e5514a4d776b9b847b4732">sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:ga10efb8df16e5514a4d776b9b847b4732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a011b3da797c0612ee26c29756fffe"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga66a011b3da797c0612ee26c29756fffe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga66a011b3da797c0612ee26c29756fffe">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="separator:ga66a011b3da797c0612ee26c29756fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadad16658a8faa8eb0617f65dc132fa"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:gadadad16658a8faa8eb0617f65dc132fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#gadadad16658a8faa8eb0617f65dc132fa">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:gadadad16658a8faa8eb0617f65dc132fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd6ca27d1c360469e447308b4b84552d"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadd6ca27d1c360469e447308b4b84552d"></a>
template&lt;typename ForwardIterator1 , typename ForwardIterator2 &gt; </td></tr>
<tr class="memitem:gadd6ca27d1c360469e447308b4b84552d"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#gadd6ca27d1c360469e447308b4b84552d">search</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</td></tr>
<tr class="memdesc:gadd6ca27d1c360469e447308b4b84552d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first subsequence [first2,last2) in [first1,last1) <br/></td></tr>
<tr class="separator:gadd6ca27d1c360469e447308b4b84552d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1313d6ca6f21539a0b2b67c7b614238"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae1313d6ca6f21539a0b2b67c7b614238"></a>
template&lt;typename ForwardIterator1 , typename ForwardIterator2 &gt; </td></tr>
<tr class="memitem:gae1313d6ca6f21539a0b2b67c7b614238"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#gae1313d6ca6f21539a0b2b67c7b614238">find_end</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</td></tr>
<tr class="memdesc:gae1313d6ca6f21539a0b2b67c7b614238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last subsequence [first2,last2) in [first1,last1) <br/></td></tr>
<tr class="separator:gae1313d6ca6f21539a0b2b67c7b614238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437828cb7c204ff44dc4d733d3e02e10"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga437828cb7c204ff44dc4d733d3e02e10"></a>
template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:ga437828cb7c204ff44dc4d733d3e02e10"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga437828cb7c204ff44dc4d733d3e02e10">search_n</a> (Iterator first, Iterator last, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, const T &amp;value)</td></tr>
<tr class="memdesc:ga437828cb7c204ff44dc4d733d3e02e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurence of <code>count</code> <code>values</code> in [first, last) <br/></td></tr>
<tr class="separator:ga437828cb7c204ff44dc4d733d3e02e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016f8e3613ee5a02dfc1306c3c25b7ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga016f8e3613ee5a02dfc1306c3c25b7ed"></a>
template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga016f8e3613ee5a02dfc1306c3c25b7ed"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga016f8e3613ee5a02dfc1306c3c25b7ed">find_first_of</a> (InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)</td></tr>
<tr class="memdesc:ga016f8e3613ee5a02dfc1306c3c25b7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches [first1,last1) for the first occurrence of an element from [first2,last2) <br/></td></tr>
<tr class="separator:ga016f8e3613ee5a02dfc1306c3c25b7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927113b88fe726a4fd7f7447523bf6b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga927113b88fe726a4fd7f7447523bf6b2"></a>
template&lt;typename InputIterator1 , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:ga927113b88fe726a4fd7f7447523bf6b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SetAlgorithms.html#ga927113b88fe726a4fd7f7447523bf6b2">includes</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)</td></tr>
<tr class="memdesc:ga927113b88fe726a4fd7f7447523bf6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if [first2,last2) is a subset of [first1,last1) <br/></td></tr>
<tr class="separator:ga927113b88fe726a4fd7f7447523bf6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b17f340d7cf48c01dd6736e181168f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga24b17f340d7cf48c01dd6736e181168f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SetAlgorithms.html#ga24b17f340d7cf48c01dd6736e181168f">set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="memdesc:ga24b17f340d7cf48c01dd6736e181168f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges [first1,last1) with [first2,last2)  <a href="group__SetAlgorithms.html#ga24b17f340d7cf48c01dd6736e181168f">More...</a><br/></td></tr>
<tr class="separator:ga24b17f340d7cf48c01dd6736e181168f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f2de2df3508c3f8b1e169af77f3e75"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad3f2de2df3508c3f8b1e169af77f3e75"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad3f2de2df3508c3f8b1e169af77f3e75"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SetAlgorithms.html#gad3f2de2df3508c3f8b1e169af77f3e75">set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="memdesc:gad3f2de2df3508c3f8b1e169af77f3e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set containing elements shared by the given ranges. <br/></td></tr>
<tr class="separator:gad3f2de2df3508c3f8b1e169af77f3e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ad3923aecce4a805232f751349b0fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga04ad3923aecce4a805232f751349b0fa"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga04ad3923aecce4a805232f751349b0fa"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SetAlgorithms.html#ga04ad3923aecce4a805232f751349b0fa">set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="memdesc:ga04ad3923aecce4a805232f751349b0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from [first1,last1) elements present in [first2,last2) <br/></td></tr>
<tr class="separator:ga04ad3923aecce4a805232f751349b0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8797b8e90ac408ce059dfbd4fce4b1bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8797b8e90ac408ce059dfbd4fce4b1bf"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga8797b8e90ac408ce059dfbd4fce4b1bf"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SetAlgorithms.html#ga8797b8e90ac408ce059dfbd4fce4b1bf">set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr class="memdesc:ga8797b8e90ac408ce059dfbd4fce4b1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs union of sets A-B and B-A. <br/></td></tr>
<tr class="separator:ga8797b8e90ac408ce059dfbd4fce4b1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b0934ac07c7bb55cbcbf6ebd5fb317"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa7b0934ac07c7bb55cbcbf6ebd5fb317"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gaa7b0934ac07c7bb55cbcbf6ebd5fb317"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConditionAlgorithms.html#gaa7b0934ac07c7bb55cbcbf6ebd5fb317">is_sorted</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:gaa7b0934ac07c7bb55cbcbf6ebd5fb317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given range is sorted. <br/></td></tr>
<tr class="separator:gaa7b0934ac07c7bb55cbcbf6ebd5fb317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523632fb8e7ee80801f71880e07928a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga523632fb8e7ee80801f71880e07928a2"></a>
template&lt;typename InputIterator1 , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:ga523632fb8e7ee80801f71880e07928a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConditionAlgorithms.html#ga523632fb8e7ee80801f71880e07928a2">lexicographical_compare</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)</td></tr>
<tr class="memdesc:ga523632fb8e7ee80801f71880e07928a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two given containers like strcmp compares strings. <br/></td></tr>
<tr class="separator:ga523632fb8e7ee80801f71880e07928a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ba7ad0c54e4dffc36965d51cfe4122"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga39ba7ad0c54e4dffc36965d51cfe4122"></a>
template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga39ba7ad0c54e4dffc36965d51cfe4122"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#ga39ba7ad0c54e4dffc36965d51cfe4122">next_permutation</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="memdesc:ga39ba7ad0c54e4dffc36965d51cfe4122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the next lexicographical permutation of [first,last). Returns false if no further permutations can be created. <br/></td></tr>
<tr class="separator:ga39ba7ad0c54e4dffc36965d51cfe4122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5378fdbd366d2cf170db066882c2409"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad5378fdbd366d2cf170db066882c2409"></a>
template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:gad5378fdbd366d2cf170db066882c2409"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#gad5378fdbd366d2cf170db066882c2409">prev_permutation</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="memdesc:gad5378fdbd366d2cf170db066882c2409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the previous lexicographical permutation of [first,last). Returns false if no further permutations can be created. <br/></td></tr>
<tr class="separator:gad5378fdbd366d2cf170db066882c2409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4848246eeaf5e37e140514b4317fd129"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4848246eeaf5e37e140514b4317fd129"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga4848246eeaf5e37e140514b4317fd129"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga4848246eeaf5e37e140514b4317fd129">max_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:ga4848246eeaf5e37e140514b4317fd129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the max element in [first,last) <br/></td></tr>
<tr class="separator:ga4848246eeaf5e37e140514b4317fd129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3777232f989774c60e42cdcc888985ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3777232f989774c60e42cdcc888985ff"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga3777232f989774c60e42cdcc888985ff"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga3777232f989774c60e42cdcc888985ff">min_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:ga3777232f989774c60e42cdcc888985ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the min element in [first,last) <br/></td></tr>
<tr class="separator:ga3777232f989774c60e42cdcc888985ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc065147f71d2d5e4875ec18c65846b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaacc065147f71d2d5e4875ec18c65846b"></a>
template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:gaacc065147f71d2d5e4875ec18c65846b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#gaacc065147f71d2d5e4875ec18c65846b">partial_sort</a> (RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last)</td></tr>
<tr class="memdesc:gaacc065147f71d2d5e4875ec18c65846b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes [first,middle) a part of the sorted array. Contents of [middle,last) is undefined. This implementation just calls stable_sort. <br/></td></tr>
<tr class="separator:gaacc065147f71d2d5e4875ec18c65846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f00dbf7222599b0255a37bfdb0dba8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga18f00dbf7222599b0255a37bfdb0dba8"></a>
template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga18f00dbf7222599b0255a37bfdb0dba8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga18f00dbf7222599b0255a37bfdb0dba8">nth_element</a> (RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last)</td></tr>
<tr class="memdesc:ga18f00dbf7222599b0255a37bfdb0dba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts <code>nth</code> element into its sorted position. In this implementation, the entire array is sorted. I can't think of any use for it where the time gained would be useful. <br/></td></tr>
<tr class="separator:ga18f00dbf7222599b0255a37bfdb0dba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020008eb3c967579544ef41a575016f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga020008eb3c967579544ef41a575016f3"></a>
template&lt;typename InputIterator , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga020008eb3c967579544ef41a575016f3"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#ga020008eb3c967579544ef41a575016f3">partial_sort_copy</a> (InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last)</td></tr>
<tr class="memdesc:ga020008eb3c967579544ef41a575016f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like partial_sort, but outputs to [result_first,result_last) <br/></td></tr>
<tr class="separator:ga020008eb3c967579544ef41a575016f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584854fe428de982bf9d576c45266c66"><td class="memTemplParams" colspan="2"><a class="anchor" id="a584854fe428de982bf9d576c45266c66"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a584854fe428de982bf9d576c45266c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_block</b> (uint8_t v)</td></tr>
<tr class="separator:a584854fe428de982bf9d576c45266c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b3e1032139bce17d6dadc92c15fa50"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0b3e1032139bce17d6dadc92c15fa50"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab0b3e1032139bce17d6dadc92c15fa50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_block</b> (uint16_t v)</td></tr>
<tr class="separator:ab0b3e1032139bce17d6dadc92c15fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b8d6b174de55307dec758d82ef5d08"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43b8d6b174de55307dec758d82ef5d08"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a43b8d6b174de55307dec758d82ef5d08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_block</b> (uint32_t v)</td></tr>
<tr class="separator:a43b8d6b174de55307dec758d82ef5d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c964e388eeafe090bb7ffb1bf280bf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c964e388eeafe090bb7ffb1bf280bf2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_n8_fast</b> (uint8_t *dest, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, uint8_t v) noexcept</td></tr>
<tr class="separator:a2c964e388eeafe090bb7ffb1bf280bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbcbddb5b5ce2b12eb550eb3460d183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dbcbddb5b5ce2b12eb550eb3460d183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_n16_fast</b> (uint16_t *dest, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, uint16_t v) noexcept</td></tr>
<tr class="separator:a6dbcbddb5b5ce2b12eb550eb3460d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f44181006bc824bfbf84e37ea8a52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa93f44181006bc824bfbf84e37ea8a52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_n32_fast</b> (uint32_t *dest, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, uint32_t v) noexcept</td></tr>
<tr class="separator:aa93f44181006bc824bfbf84e37ea8a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeee58586aecc1f16f0b70484211dda7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeee58586aecc1f16f0b70484211dda7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aaeee58586aecc1f16f0b70484211dda7">rotate_fast</a> (void *first, void *middle, void *last) noexcept</td></tr>
<tr class="memdesc:aaeee58586aecc1f16f0b70484211dda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges ranges [first, middle) and [middle, last) <br/></td></tr>
<tr class="separator:aaeee58586aecc1f16f0b70484211dda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9276f05c8ab39a4430bc81a9d73a7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc9276f05c8ab39a4430bc81a9d73a7e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>popcount</b> (uint32_t v) noexcept</td></tr>
<tr class="separator:afc9276f05c8ab39a4430bc81a9d73a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf5fb5bed53324f6e81f775a009d641"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cf5fb5bed53324f6e81f775a009d641"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a4cf5fb5bed53324f6e81f775a009d641">popcount</a> (uint64_t v) noexcept</td></tr>
<tr class="memdesc:a4cf5fb5bed53324f6e81f775a009d641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1s in <code>v</code> in binary. <br/></td></tr>
<tr class="separator:a4cf5fb5bed53324f6e81f775a009d641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee49e575d1dd3e5c6d6ec9a0a3b5c0a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee49e575d1dd3e5c6d6ec9a0a3b5c0a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee49e575d1dd3e5c6d6ec9a0a3b5c0a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structustl_1_1tm_1_1RemoveReference.html">tm::RemoveReference</a><br class="typebreak"/>
&lt; T &gt;::Result &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move</b> (T &amp;&amp;v) noexcept</td></tr>
<tr class="separator:aee49e575d1dd3e5c6d6ec9a0a3b5c0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f34c5a2533a516e93157e96719c97b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f34c5a2533a516e93157e96719c97b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f34c5a2533a516e93157e96719c97b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forward</b> (typename <a class="el" href="structustl_1_1tm_1_1RemoveReference.html">tm::RemoveReference</a>&lt; T &gt;::Result &amp;v) noexcept</td></tr>
<tr class="separator:a5f34c5a2533a516e93157e96719c97b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a8c47445a45e7bc5039005d269b91f"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1a8c47445a45e7bc5039005d269b91f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1a8c47445a45e7bc5039005d269b91f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forward</b> (typename <a class="el" href="structustl_1_1tm_1_1RemoveReference.html">tm::RemoveReference</a>&lt; T &gt;::Result &amp;&amp;v) noexcept</td></tr>
<tr class="separator:af1a8c47445a45e7bc5039005d269b91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75c4631242986c405f14ce76f97499b4"><td class="memTemplParams" colspan="2">template&lt;typename Assignable &gt; </td></tr>
<tr class="memitem:ga75c4631242986c405f14ce76f97499b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SwapAlgorithms.html#ga75c4631242986c405f14ce76f97499b4">swap</a> (Assignable &amp;a, Assignable &amp;b)</td></tr>
<tr class="separator:ga75c4631242986c405f14ce76f97499b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70beeb79393e6c3f5c86237f501a583b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga70beeb79393e6c3f5c86237f501a583b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SwapAlgorithms.html#ga70beeb79393e6c3f5c86237f501a583b">iter_swap</a> (Iterator a, Iterator b)</td></tr>
<tr class="separator:ga70beeb79393e6c3f5c86237f501a583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd931061ff91b8bc27954db50d09843"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaffd931061ff91b8bc27954db50d09843"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaffd931061ff91b8bc27954db50d09843">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:gaffd931061ff91b8bc27954db50d09843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012b47e2efb4ab384d9c3b47fbb70365"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga012b47e2efb4ab384d9c3b47fbb70365"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga012b47e2efb4ab384d9c3b47fbb70365">copy_n</a> (InputIterator first, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, OutputIterator result)</td></tr>
<tr class="separator:ga012b47e2efb4ab384d9c3b47fbb70365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7c6e90e73c912bb2d85e2f44da00188b"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga7c6e90e73c912bb2d85e2f44da00188b">copy_backward</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy copies elements from the range (last, first] to result.Copies elements starting at last, decrementing both last and result. <br/></td></tr>
<tr class="separator:ga7c6e90e73c912bb2d85e2f44da00188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad486998e69ac22172965db1c8b893e9a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:gad486998e69ac22172965db1c8b893e9a"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gad486998e69ac22172965db1c8b893e9a">for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>
<tr class="separator:gad486998e69ac22172965db1c8b893e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf994672c3ab88b90813b73054175b0d0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:gaf994672c3ab88b90813b73054175b0d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#gaf994672c3ab88b90813b73054175b0d0">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="separator:gaf994672c3ab88b90813b73054175b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539b0f05dc80ccc8abaef0d95eb4045e"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga539b0f05dc80ccc8abaef0d95eb4045e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#ga539b0f05dc80ccc8abaef0d95eb4045e">fill_n</a> (OutputIterator first, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, const T &amp;value)</td></tr>
<tr class="separator:ga539b0f05dc80ccc8abaef0d95eb4045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb6dbf43b164f8a37335c33e0235397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeb6dbf43b164f8a37335c33e0235397"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_n_fast</b> (const void *src, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, void *dest) noexcept</td></tr>
<tr class="separator:aaeb6dbf43b164f8a37335c33e0235397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d274ad35368ee3d66c7ab1f29275a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94d274ad35368ee3d66c7ab1f29275a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_backward_fast</b> (const void *first, const void *last, void *result) noexcept</td></tr>
<tr class="separator:a94d274ad35368ee3d66c7ab1f29275a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e7b6583d122085d919b66216ccacce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2e7b6583d122085d919b66216ccacce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2e7b6583d122085d919b66216ccacce"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unrolled_copy</b> (const T *first, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, T *result)</td></tr>
<tr class="separator:ac2e7b6583d122085d919b66216ccacce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae317bf3dcd2f41274142fe8372c98b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ae317bf3dcd2f41274142fe8372c98b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9ae317bf3dcd2f41274142fe8372c98b"><td class="memTemplItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_backward</b> (const uint8_t *first, const uint8_t *last, uint8_t *result)</td></tr>
<tr class="separator:a9ae317bf3dcd2f41274142fe8372c98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e375d320dc31d9b59510a9361fc8f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2e375d320dc31d9b59510a9361fc8f0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2e375d320dc31d9b59510a9361fc8f0"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unrolled_fill</b> (T *result, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, T value)</td></tr>
<tr class="separator:ab2e375d320dc31d9b59510a9361fc8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc43b123f3217121cdee0537dfe80b3"><td class="memTemplParams" colspan="2"><a class="anchor" id="affc43b123f3217121cdee0537dfe80b3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:affc43b123f3217121cdee0537dfe80b3"><td class="memTemplItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unrolled_fill</b> (uint8_t *result, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, uint8_t value)</td></tr>
<tr class="separator:affc43b123f3217121cdee0537dfe80b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde059f1ac85a8026fd308beac03afa"><td class="memTemplParams" colspan="2"><a class="anchor" id="afdde059f1ac85a8026fd308beac03afa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afdde059f1ac85a8026fd308beac03afa"><td class="memTemplItemLeft" align="right" valign="top">uint16_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unrolled_fill</b> (uint16_t *result, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, uint16_t value)</td></tr>
<tr class="separator:afdde059f1ac85a8026fd308beac03afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9ad83f75b4041617c16de10855ac76"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b9ad83f75b4041617c16de10855ac76"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3b9ad83f75b4041617c16de10855ac76"><td class="memTemplItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unrolled_fill</b> (uint32_t *result, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, uint32_t value)</td></tr>
<tr class="separator:a3b9ad83f75b4041617c16de10855ac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696b3a9578df535f0607e93584ec620a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a696b3a9578df535f0607e93584ec620a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a696b3a9578df535f0607e93584ec620a"><td class="memTemplItemLeft" align="right" valign="top">float *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unrolled_fill</b> (float *result, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, float value)</td></tr>
<tr class="separator:a696b3a9578df535f0607e93584ec620a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab198744282029c86a91a104fcf2d41a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ab198744282029c86a91a104fcf2d41a1">convert_to_bitstring</a> (const bitset_value_type *v, size_t n, <a class="el" href="classustl_1_1string.html">string</a> &amp;buf) noexcept</td></tr>
<tr class="separator:ab198744282029c86a91a104fcf2d41a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbca302b8253417c015653b63e9a4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94cbca302b8253417c015653b63e9a4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a94cbca302b8253417c015653b63e9a4f">convert_from_bitstring</a> (const <a class="el" href="classustl_1_1string.html">string</a> &amp;buf, bitset_value_type *v, size_t n) noexcept</td></tr>
<tr class="memdesc:a94cbca302b8253417c015653b63e9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bits from <code>buf</code> as MSB "1011001..." LSB into <code>v</code> of size <code>n</code>. <br/></td></tr>
<tr class="separator:a94cbca302b8253417c015653b63e9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420b212976e71f04f4c32326194e948e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga420b212976e71f04f4c32326194e948e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga420b212976e71f04f4c32326194e948e">copy</a> (const Container &amp;ctr, OutputIterator result)</td></tr>
<tr class="separator:ga420b212976e71f04f4c32326194e948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64c71b8c66dcc68c43b373c7b9b2393"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gaa64c71b8c66dcc68c43b373c7b9b2393"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaa64c71b8c66dcc68c43b373c7b9b2393">copy_if</a> (Container &amp;ctr, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:gaa64c71b8c66dcc68c43b373c7b9b2393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7336da576007f507195e75b65906265"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:gae7336da576007f507195e75b65906265"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae7336da576007f507195e75b65906265">for_each</a> (Container &amp;ctr, UnaryFunction f)</td></tr>
<tr class="separator:gae7336da576007f507195e75b65906265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfbc6e6f1999aef61d107489d5b437b"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga8bfbc6e6f1999aef61d107489d5b437b"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga8bfbc6e6f1999aef61d107489d5b437b">for_each</a> (const Container &amp;ctr, UnaryFunction f)</td></tr>
<tr class="separator:ga8bfbc6e6f1999aef61d107489d5b437b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189ddff48e22b6825d88543441185ce7"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename EqualityComparable &gt; </td></tr>
<tr class="memitem:ga189ddff48e22b6825d88543441185ce7"><td class="memTemplItemLeft" align="right" valign="top">Container::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga189ddff48e22b6825d88543441185ce7">find</a> (const Container &amp;ctr, const EqualityComparable &amp;value)</td></tr>
<tr class="separator:ga189ddff48e22b6825d88543441185ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5f6e8779511507a8be7d274714daa5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b5f6e8779511507a8be7d274714daa5"></a>
template&lt;typename Container , typename EqualityComparable &gt; </td></tr>
<tr class="memitem:a3b5f6e8779511507a8be7d274714daa5"><td class="memTemplItemLeft" align="right" valign="top">Container::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (Container &amp;ctr, const EqualityComparable &amp;value)</td></tr>
<tr class="separator:a3b5f6e8779511507a8be7d274714daa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e779efc747400bd68bf2c0b32155ff4"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:ga2e779efc747400bd68bf2c0b32155ff4"><td class="memTemplItemLeft" align="right" valign="top">Container::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga2e779efc747400bd68bf2c0b32155ff4">find_if</a> (const Container &amp;ctr, Predicate pred)</td></tr>
<tr class="separator:ga2e779efc747400bd68bf2c0b32155ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8138ccb3cdd421d7fd805390fe2382d2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8138ccb3cdd421d7fd805390fe2382d2"></a>
template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:a8138ccb3cdd421d7fd805390fe2382d2"><td class="memTemplItemLeft" align="right" valign="top">Container::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (Container &amp;ctr, Predicate pred)</td></tr>
<tr class="separator:a8138ccb3cdd421d7fd805390fe2382d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc8bcf5b3c54de7926f2103ba164795"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename EqualityComparable &gt; </td></tr>
<tr class="memitem:gafcc8bcf5b3c54de7926f2103ba164795"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConditionAlgorithms.html#gafcc8bcf5b3c54de7926f2103ba164795">count</a> (const Container &amp;ctr, const EqualityComparable &amp;value)</td></tr>
<tr class="separator:gafcc8bcf5b3c54de7926f2103ba164795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f45926b1d7879e4bdc48670442b7293"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:ga1f45926b1d7879e4bdc48670442b7293"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConditionAlgorithms.html#ga1f45926b1d7879e4bdc48670442b7293">count_if</a> (const Container &amp;ctr, Predicate pred)</td></tr>
<tr class="separator:ga1f45926b1d7879e4bdc48670442b7293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c67dd2fddca5eec86a948bfb52be4ff"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga0c67dd2fddca5eec86a948bfb52be4ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga0c67dd2fddca5eec86a948bfb52be4ff">transform</a> (Container &amp;ctr, UnaryFunction op)</td></tr>
<tr class="separator:ga0c67dd2fddca5eec86a948bfb52be4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595997b23ca65b0e63f01794c5db99a5"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga595997b23ca65b0e63f01794c5db99a5"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga595997b23ca65b0e63f01794c5db99a5">transform</a> (Container &amp;ctr, OutputIterator result, UnaryFunction op)</td></tr>
<tr class="separator:ga595997b23ca65b0e63f01794c5db99a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2102561c0d380e16e1effabeba58754"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename InputIterator , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gae2102561c0d380e16e1effabeba58754"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae2102561c0d380e16e1effabeba58754">transform</a> (Container &amp;ctr, InputIterator first, OutputIterator result, BinaryFunction op)</td></tr>
<tr class="separator:gae2102561c0d380e16e1effabeba58754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a666ae8eb20398682c574b8efb595ea"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:ga8a666ae8eb20398682c574b8efb595ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga8a666ae8eb20398682c574b8efb595ea">replace</a> (Container &amp;ctr, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:ga8a666ae8eb20398682c574b8efb595ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88aa14b0e4f6d2a41c8cb84cb6bf7d09"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga88aa14b0e4f6d2a41c8cb84cb6bf7d09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga88aa14b0e4f6d2a41c8cb84cb6bf7d09">replace_if</a> (Container &amp;ctr, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga88aa14b0e4f6d2a41c8cb84cb6bf7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06a187fb030b8f86fe5f0bb35f1433f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:gaf06a187fb030b8f86fe5f0bb35f1433f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaf06a187fb030b8f86fe5f0bb35f1433f">replace_copy</a> (const Container &amp;ctr, OutputIterator result, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr class="separator:gaf06a187fb030b8f86fe5f0bb35f1433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4600f1b212331c8ce198fb1af1de15"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga6d4600f1b212331c8ce198fb1af1de15"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga6d4600f1b212331c8ce198fb1af1de15">replace_copy_if</a> (const Container &amp;ctr, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga6d4600f1b212331c8ce198fb1af1de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc310dd404298363802d62408d34a1b"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:ga5cc310dd404298363802d62408d34a1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#ga5cc310dd404298363802d62408d34a1b">fill</a> (Container &amp;ctr, const T &amp;value)</td></tr>
<tr class="separator:ga5cc310dd404298363802d62408d34a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc667e1354cc3eb585504d92e1436069"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Generator &gt; </td></tr>
<tr class="memitem:gabc667e1354cc3eb585504d92e1436069"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#gabc667e1354cc3eb585504d92e1436069">generate</a> (Container &amp;ctr, Generator gen)</td></tr>
<tr class="separator:gabc667e1354cc3eb585504d92e1436069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5053fa79c0bfe0b68a17211df7b887"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gafb5053fa79c0bfe0b68a17211df7b887"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneratorAlgorithms.html#gafb5053fa79c0bfe0b68a17211df7b887">random_shuffle</a> (Container &amp;ctr)</td></tr>
<tr class="separator:gafb5053fa79c0bfe0b68a17211df7b887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189fa3d39078139d039cea754c490310"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga189fa3d39078139d039cea754c490310"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga189fa3d39078139d039cea754c490310">remove_copy</a> (const Container &amp;ctr, OutputIterator result, const T &amp;value)</td></tr>
<tr class="separator:ga189fa3d39078139d039cea754c490310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae020c456b0dcdb049c37b08bc9b87ee3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gae020c456b0dcdb049c37b08bc9b87ee3"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gae020c456b0dcdb049c37b08bc9b87ee3">remove_copy_if</a> (const Container &amp;ctr, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:gae020c456b0dcdb049c37b08bc9b87ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc16bfb34449db8062d3d1a212713efa"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:gabc16bfb34449db8062d3d1a212713efa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gabc16bfb34449db8062d3d1a212713efa">remove</a> (Container &amp;ctr, const T &amp;value)</td></tr>
<tr class="separator:gabc16bfb34449db8062d3d1a212713efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5a9488053677405afa744edf815b77"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga0a5a9488053677405afa744edf815b77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga0a5a9488053677405afa744edf815b77">remove</a> (Container &amp;ctr, ForwardIterator rfirst, ForwardIterator rlast)</td></tr>
<tr class="separator:ga0a5a9488053677405afa744edf815b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b3430a2ea014523e9f54b538b7fecf"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:gab9b3430a2ea014523e9f54b538b7fecf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gab9b3430a2ea014523e9f54b538b7fecf">remove_if</a> (Container &amp;ctr, Predicate pred)</td></tr>
<tr class="separator:gab9b3430a2ea014523e9f54b538b7fecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013e60a5eb03c93781f9ade1c724beec"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga013e60a5eb03c93781f9ade1c724beec"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga013e60a5eb03c93781f9ade1c724beec">unique_copy</a> (const Container &amp;ctr, OutputIterator result)</td></tr>
<tr class="separator:ga013e60a5eb03c93781f9ade1c724beec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18dd0f3a49cf57f7b06b77df5a379e0"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gad18dd0f3a49cf57f7b06b77df5a379e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gad18dd0f3a49cf57f7b06b77df5a379e0">unique</a> (Container &amp;ctr)</td></tr>
<tr class="separator:gad18dd0f3a49cf57f7b06b77df5a379e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040d93fb7659f4a30075759df2db827e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga040d93fb7659f4a30075759df2db827e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga040d93fb7659f4a30075759df2db827e">unique</a> (Container &amp;ctr, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga040d93fb7659f4a30075759df2db827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86967546e25f8091fa08595de9afe9d4"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga86967546e25f8091fa08595de9afe9d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga86967546e25f8091fa08595de9afe9d4">reverse</a> (Container &amp;ctr)</td></tr>
<tr class="separator:ga86967546e25f8091fa08595de9afe9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06e3b30adb83643e79e738ed7477e45"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gaf06e3b30adb83643e79e738ed7477e45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaf06e3b30adb83643e79e738ed7477e45">rotate</a> (Container &amp;ctr, off_t offset)</td></tr>
<tr class="separator:gaf06e3b30adb83643e79e738ed7477e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408ded6c4704c9c83e4c0779dbd5c868"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:ga408ded6c4704c9c83e4c0779dbd5c868"><td class="memTemplItemLeft" align="right" valign="top">Container::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga408ded6c4704c9c83e4c0779dbd5c868">lower_bound</a> (const Container &amp;ctr, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:ga408ded6c4704c9c83e4c0779dbd5c868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f8248b998b16bc7923e33016f57feb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67f8248b998b16bc7923e33016f57feb"></a>
template&lt;typename Container , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:a67f8248b998b16bc7923e33016f57feb"><td class="memTemplItemLeft" align="right" valign="top">Container::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (Container &amp;ctr, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:a67f8248b998b16bc7923e33016f57feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18a6b00a59604b976207270bc55ff7e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:gab18a6b00a59604b976207270bc55ff7e"><td class="memTemplItemLeft" align="right" valign="top">Container::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#gab18a6b00a59604b976207270bc55ff7e">upper_bound</a> (const Container &amp;ctr, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:gab18a6b00a59604b976207270bc55ff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dc33b8f4ebad5908d2f974d5c5a0e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68dc33b8f4ebad5908d2f974d5c5a0e0"></a>
template&lt;typename Container , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:a68dc33b8f4ebad5908d2f974d5c5a0e0"><td class="memTemplItemLeft" align="right" valign="top">Container::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (Container &amp;ctr, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:a68dc33b8f4ebad5908d2f974d5c5a0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad1a5be5d178ed57915c11166df88d8"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga3ad1a5be5d178ed57915c11166df88d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga3ad1a5be5d178ed57915c11166df88d8">binary_search</a> (const Container &amp;ctr, const typename Container::value_type &amp;value)</td></tr>
<tr class="separator:ga3ad1a5be5d178ed57915c11166df88d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8bd58118eb383af25948fab2817382"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa8bd58118eb383af25948fab2817382"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aaa8bd58118eb383af25948fab2817382"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search</b> (Container &amp;ctr, const typename Container::value_type &amp;value)</td></tr>
<tr class="separator:aaa8bd58118eb383af25948fab2817382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157c717ab32c705ebbadf298a18567d1"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:ga157c717ab32c705ebbadf298a18567d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; typename <br class="typebreak"/>
Container::const_iterator, <br class="typebreak"/>
typename <br class="typebreak"/>
Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SearchingAlgorithms.html#ga157c717ab32c705ebbadf298a18567d1">equal_range</a> (const Container &amp;ctr, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:ga157c717ab32c705ebbadf298a18567d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5781eec59962f5a0cc4c4b25c3654"><td class="memTemplParams" colspan="2"><a class="anchor" id="af7f5781eec59962f5a0cc4c4b25c3654"></a>
template&lt;typename Container , typename LessThanComparable &gt; </td></tr>
<tr class="memitem:af7f5781eec59962f5a0cc4c4b25c3654"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; typename <br class="typebreak"/>
Container::iterator, typename <br class="typebreak"/>
Container::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (Container &amp;ctr, const LessThanComparable &amp;value)</td></tr>
<tr class="separator:af7f5781eec59962f5a0cc4c4b25c3654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e58f79594b88ddd5cc722ca895c575"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga99e58f79594b88ddd5cc722ca895c575"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#ga99e58f79594b88ddd5cc722ca895c575">sort</a> (Container &amp;ctr)</td></tr>
<tr class="separator:ga99e58f79594b88ddd5cc722ca895c575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc16c725b4901c1c15b392012d1f7f2"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:gadcc16c725b4901c1c15b392012d1f7f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#gadcc16c725b4901c1c15b392012d1f7f2">sort</a> (Container &amp;ctr, Compare comp)</td></tr>
<tr class="separator:gadcc16c725b4901c1c15b392012d1f7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9931c15173d165da1217d95896c72574"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga9931c15173d165da1217d95896c72574"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#ga9931c15173d165da1217d95896c72574">stable_sort</a> (Container &amp;ctr)</td></tr>
<tr class="separator:ga9931c15173d165da1217d95896c72574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb4772db6bd773e5092f559592476e6"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:gadcb4772db6bd773e5092f559592476e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#gadcb4772db6bd773e5092f559592476e6">stable_sort</a> (Container &amp;ctr, Compare comp)</td></tr>
<tr class="separator:gadcb4772db6bd773e5092f559592476e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c2024ca637aceb22aa6863fa28b5e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a63c2024ca637aceb22aa6863fa28b5e7"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a63c2024ca637aceb22aa6863fa28b5e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1istream.html">istream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a63c2024ca637aceb22aa6863fa28b5e7">nr_container_read</a> (<a class="el" href="classustl_1_1istream.html">istream</a> &amp;is, Container &amp;v)</td></tr>
<tr class="memdesc:a63c2024ca637aceb22aa6863fa28b5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads fixed size container <code>v</code> from stream <code>is</code>. <br/></td></tr>
<tr class="separator:a63c2024ca637aceb22aa6863fa28b5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0b89a264fbf22f4e8d18d7e4cb714e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c0b89a264fbf22f4e8d18d7e4cb714e"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a2c0b89a264fbf22f4e8d18d7e4cb714e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a2c0b89a264fbf22f4e8d18d7e4cb714e">nr_container_write</a> (<a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;os, const Container &amp;v)</td></tr>
<tr class="memdesc:a2c0b89a264fbf22f4e8d18d7e4cb714e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes fixed size container <code>v</code> into stream <code>os</code>. <br/></td></tr>
<tr class="separator:a2c0b89a264fbf22f4e8d18d7e4cb714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b38eec9b37529f7075ec1b305160d14"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b38eec9b37529f7075ec1b305160d14"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a9b38eec9b37529f7075ec1b305160d14"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a9b38eec9b37529f7075ec1b305160d14">nr_container_stream_size</a> (const Container &amp;v)</td></tr>
<tr class="memdesc:a9b38eec9b37529f7075ec1b305160d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the stream size of a fixed size standard container. <br/></td></tr>
<tr class="separator:a9b38eec9b37529f7075ec1b305160d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3d572dfb07f22f770f2ee7a7b1fe67"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc3d572dfb07f22f770f2ee7a7b1fe67"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:acc3d572dfb07f22f770f2ee7a7b1fe67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1istream.html">istream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#acc3d572dfb07f22f770f2ee7a7b1fe67">container_read</a> (<a class="el" href="classustl_1_1istream.html">istream</a> &amp;is, Container &amp;v)</td></tr>
<tr class="memdesc:acc3d572dfb07f22f770f2ee7a7b1fe67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads container <code>v</code> from stream <code>is</code>. <br/></td></tr>
<tr class="separator:acc3d572dfb07f22f770f2ee7a7b1fe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847b2d605ee89e390d0e282051a6be37"><td class="memTemplParams" colspan="2"><a class="anchor" id="a847b2d605ee89e390d0e282051a6be37"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a847b2d605ee89e390d0e282051a6be37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a847b2d605ee89e390d0e282051a6be37">container_write</a> (<a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;os, const Container &amp;v)</td></tr>
<tr class="memdesc:a847b2d605ee89e390d0e282051a6be37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the vector to stream <code>os</code>. <br/></td></tr>
<tr class="separator:a847b2d605ee89e390d0e282051a6be37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e11cd33f5ca9dc2bd4913a3f41d29d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0e11cd33f5ca9dc2bd4913a3f41d29d"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab0e11cd33f5ca9dc2bd4913a3f41d29d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ab0e11cd33f5ca9dc2bd4913a3f41d29d">container_stream_size</a> (const Container &amp;v)</td></tr>
<tr class="memdesc:ab0e11cd33f5ca9dc2bd4913a3f41d29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the stream size of a standard container. <br/></td></tr>
<tr class="separator:ab0e11cd33f5ca9dc2bd4913a3f41d29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ab2b09f5981a0ce0dba9c9071df0da"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2ab2b09f5981a0ce0dba9c9071df0da"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2ab2b09f5981a0ce0dba9c9071df0da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ac2ab2b09f5981a0ce0dba9c9071df0da">container_element_text_write</a> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const T &amp;v)</td></tr>
<tr class="memdesc:ac2ab2b09f5981a0ce0dba9c9071df0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes element <code>v</code> into stream <code>os</code> as text. Specialize to custom print elements. <br/></td></tr>
<tr class="separator:ac2ab2b09f5981a0ce0dba9c9071df0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fb1f51c46c362e2bae3f7b49e0c6da"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0fb1f51c46c362e2bae3f7b49e0c6da"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab0fb1f51c46c362e2bae3f7b49e0c6da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ab0fb1f51c46c362e2bae3f7b49e0c6da">container_text_write</a> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const Container &amp;v)</td></tr>
<tr class="memdesc:ab0fb1f51c46c362e2bae3f7b49e0c6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes container <code>v</code> into stream <code>os</code> as text. <br/></td></tr>
<tr class="separator:ab0fb1f51c46c362e2bae3f7b49e0c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988861257997d375e656346ca308e512"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a988861257997d375e656346ca308e512">demangle_type_name</a> (char *buf, size_t bufSize, size_t *pdmSize) noexcept</td></tr>
<tr class="memdesc:a988861257997d375e656346ca308e512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses C++ ABI call, if available to demangle the contents of <code>buf</code>.  <a href="#a988861257997d375e656346ca308e512">More...</a><br/></td></tr>
<tr class="separator:a988861257997d375e656346ca308e512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692b000017859bcaa7f5fc26171da68e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Result &gt; </td></tr>
<tr class="memitem:ga692b000017859bcaa7f5fc26171da68e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pointer__to__unary__function.html">pointer_to_unary_function</a>&lt; Arg, <br class="typebreak"/>
Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga692b000017859bcaa7f5fc26171da68e">ptr_fun</a> (Result(*pfn)(Arg))</td></tr>
<tr class="separator:ga692b000017859bcaa7f5fc26171da68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134fe8f77eeaaf8ec0cbe57c70763455"><td class="memTemplParams" colspan="2">template&lt;typename Arg1 , typename Arg2 , typename Result &gt; </td></tr>
<tr class="memitem:ga134fe8f77eeaaf8ec0cbe57c70763455"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pointer__to__binary__function.html">pointer_to_binary_function</a><br class="typebreak"/>
&lt; Arg1, Arg2, Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga134fe8f77eeaaf8ec0cbe57c70763455">ptr_fun</a> (Result(*pfn)(Arg1, Arg2))</td></tr>
<tr class="separator:ga134fe8f77eeaaf8ec0cbe57c70763455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be1e0def5a92308f595105e8787a32a"><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction &gt; </td></tr>
<tr class="memitem:ga1be1e0def5a92308f595105e8787a32a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1unary__negate.html">unary_negate</a>&lt; UnaryFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga1be1e0def5a92308f595105e8787a32a">unary_negator</a> (UnaryFunction pfn)</td></tr>
<tr class="separator:ga1be1e0def5a92308f595105e8787a32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17eadb603a5cd87eefde8b362440c061"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga17eadb603a5cd87eefde8b362440c061"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1binder1st.html">binder1st</a>&lt; BinaryFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga17eadb603a5cd87eefde8b362440c061">bind1st</a> (BinaryFunction pfn, typename BinaryFunction::first_argument_type v)</td></tr>
<tr class="separator:ga17eadb603a5cd87eefde8b362440c061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4e019298b2082e148d74eb73948692"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga6e4e019298b2082e148d74eb73948692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1binder2nd.html">binder2nd</a>&lt; BinaryFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga6e4e019298b2082e148d74eb73948692">bind2nd</a> (BinaryFunction pfn, typename BinaryFunction::second_argument_type v)</td></tr>
<tr class="separator:ga6e4e019298b2082e148d74eb73948692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78abf2b817501b4f18ffde6809ad7d0c"><td class="memTemplParams" colspan="2">template&lt;typename Operation1 , typename Operation2 &gt; </td></tr>
<tr class="memitem:ga78abf2b817501b4f18ffde6809ad7d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1unary__compose.html">unary_compose</a>&lt; Operation1, <br class="typebreak"/>
Operation2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga78abf2b817501b4f18ffde6809ad7d0c">compose1</a> (const Operation1 &amp;f, const Operation2 &amp;g)</td></tr>
<tr class="separator:ga78abf2b817501b4f18ffde6809ad7d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9fe0b2716cc7faf07098f19db7a7858"><td class="memTemplParams" colspan="2">template&lt;typename Operation1 , typename Operation2 , typename Operation3 &gt; </td></tr>
<tr class="memitem:gac9fe0b2716cc7faf07098f19db7a7858"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1binary__compose.html">binary_compose</a>&lt; Operation1, <br class="typebreak"/>
Operation2, Operation3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#gac9fe0b2716cc7faf07098f19db7a7858">compose2</a> (const Operation1 &amp;f, const Operation2 &amp;g, const Operation3 &amp;h)</td></tr>
<tr class="separator:gac9fe0b2716cc7faf07098f19db7a7858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b12abc35eccb51beb510fbd3d621142"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:ga7b12abc35eccb51beb510fbd3d621142"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var1_t&lt; <a class="el" href="classustl_1_1binder2nd.html">binder2nd</a><br class="typebreak"/>
&lt; equal_to&lt; VT &gt; &gt;, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga7b12abc35eccb51beb510fbd3d621142">mem_var_equal_to</a> (const VT T::*mvp, const VT &amp;v)</td></tr>
<tr class="separator:ga7b12abc35eccb51beb510fbd3d621142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7778bd67b0068ced3e711aae65adc417"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:ga7778bd67b0068ced3e711aae65adc417"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var1_t&lt; <a class="el" href="classustl_1_1binder2nd.html">binder2nd</a><br class="typebreak"/>
&lt; less&lt; VT &gt; &gt;, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#ga7778bd67b0068ced3e711aae65adc417">mem_var_less</a> (const VT T::*mvp, const VT &amp;v)</td></tr>
<tr class="separator:ga7778bd67b0068ced3e711aae65adc417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82a5be23fb831c5a77c7d453b8c85a4"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:gad82a5be23fb831c5a77c7d453b8c85a4"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var2_t&lt; equal_to&lt; VT &gt;<br class="typebreak"/>
, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#gad82a5be23fb831c5a77c7d453b8c85a4">mem_var_equal_to</a> (const VT T::*mvp)</td></tr>
<tr class="separator:gad82a5be23fb831c5a77c7d453b8c85a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe924449ab4bd470bfb963563fe108ba"><td class="memTemplParams" colspan="2">template&lt;class T , typename VT &gt; </td></tr>
<tr class="memitem:gafe924449ab4bd470bfb963563fe108ba"><td class="memTemplItemLeft" align="right" valign="top">const_mem_var2_t&lt; less&lt; VT &gt;<br class="typebreak"/>
, T, VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FunctorAccessors.html#gafe924449ab4bd470bfb963563fe108ba">mem_var_less</a> (const VT T::*mvp)</td></tr>
<tr class="separator:gafe924449ab4bd470bfb963563fe108ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3fcf90ac9122f6a4606c85b643f37fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad3fcf90ac9122f6a4606c85b643f37fe"></a>
template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gad3fcf90ac9122f6a4606c85b643f37fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConditionAlgorithms.html#gad3fcf90ac9122f6a4606c85b643f37fe">is_heap</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="memdesc:gad3fcf90ac9122f6a4606c85b643f37fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given range is a heap under <code>comp</code>. A heap is a sequentially encoded binary tree where for every node comp(node,child1) is false and comp(node,child2) is false. <br/></td></tr>
<tr class="separator:gad3fcf90ac9122f6a4606c85b643f37fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94c0e9d3d9c2f737c7a8d47b9608b351"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga94c0e9d3d9c2f737c7a8d47b9608b351"></a>
template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga94c0e9d3d9c2f737c7a8d47b9608b351"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#ga94c0e9d3d9c2f737c7a8d47b9608b351">make_heap</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="memdesc:ga94c0e9d3d9c2f737c7a8d47b9608b351"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_heap turns the range [first, last) into a heap At completion, is_heap (first, last, comp) is true. The algorithm is adapted from "Classic Data Structures in C++" by Timothy Budd. <br/></td></tr>
<tr class="separator:ga94c0e9d3d9c2f737c7a8d47b9608b351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaedfffcaeab46ff4ae8ba5f1404d87aa8"></a>
template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#gaedfffcaeab46ff4ae8ba5f1404d87aa8">push_heap</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="memdesc:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the *&ndash;last into the preceeding range assumed to be a heap. <br/></td></tr>
<tr class="separator:gaedfffcaeab46ff4ae8ba5f1404d87aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2b7f2099a917f04bd58283d4c8ed34"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga9e2b7f2099a917f04bd58283d4c8ed34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MutatingAlgorithms.html#ga9e2b7f2099a917f04bd58283d4c8ed34">pop_heap</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="separator:ga9e2b7f2099a917f04bd58283d4c8ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab358f9493a0e80f2dc6fdf14f6dce111"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gab358f9493a0e80f2dc6fdf14f6dce111"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SortingAlgorithms.html#gab358f9493a0e80f2dc6fdf14f6dce111">sort_heap</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="separator:gab358f9493a0e80f2dc6fdf14f6dce111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e08e5360f4acea2d5b38166db453a"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb8e08e5360f4acea2d5b38166db453a"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:afb8e08e5360f4acea2d5b38166db453a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1insert__iterator.html">insert_iterator</a>&lt; Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#afb8e08e5360f4acea2d5b38166db453a">inserter</a> (Container &amp;ctr, typename Container::iterator ip)</td></tr>
<tr class="memdesc:afb8e08e5360f4acea2d5b38166db453a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classustl_1_1insert__iterator.html" title="Calls insert on bound container for each assignment. ">insert_iterator</a> for <code>ctr</code>. <br/></td></tr>
<tr class="separator:afb8e08e5360f4acea2d5b38166db453a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eaed622d2b6e72161581694c73e75b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20eaed622d2b6e72161581694c73e75b"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a20eaed622d2b6e72161581694c73e75b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a20eaed622d2b6e72161581694c73e75b">back_inserter</a> (Container &amp;ctr)</td></tr>
<tr class="memdesc:a20eaed622d2b6e72161581694c73e75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classustl_1_1back__insert__iterator.html" title="Calls push_back on bound container for each assignment. ">back_insert_iterator</a> for <code>ctr</code>. <br/></td></tr>
<tr class="separator:a20eaed622d2b6e72161581694c73e75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2371f57e0ffe04f626fe72dcc68749b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2371f57e0ffe04f626fe72dcc68749b1"></a>
template&lt;typename RandomAccessIterator , typename IndexIterator &gt; </td></tr>
<tr class="memitem:a2371f57e0ffe04f626fe72dcc68749b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1index__iterate.html">index_iterate</a><br class="typebreak"/>
&lt; RandomAccessIterator, <br class="typebreak"/>
IndexIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a2371f57e0ffe04f626fe72dcc68749b1">index_iterator</a> (RandomAccessIterator ibase, IndexIterator iindex)</td></tr>
<tr class="memdesc:a2371f57e0ffe04f626fe72dcc68749b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classustl_1_1index__iterate.html" title="Allows iteration through an index container. ">index_iterate</a> for <code>ibase</code> over <code>iindex</code>. <br/></td></tr>
<tr class="separator:a2371f57e0ffe04f626fe72dcc68749b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c267e68ef570e9749ffed0ee581ef7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a07c267e68ef570e9749ffed0ee581ef7"></a>
template&lt;typename IndexContainer , typename IteratorContainer &gt; </td></tr>
<tr class="memitem:a07c267e68ef570e9749ffed0ee581ef7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a07c267e68ef570e9749ffed0ee581ef7">indexv_to_iteratorv</a> (typename IteratorContainer::value_type ibase, const IndexContainer &amp;xc, IteratorContainer &amp;ic)</td></tr>
<tr class="memdesc:a07c267e68ef570e9749ffed0ee581ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the indexes in <code>xc</code> to iterators in <code>ic</code> of base <code>ibase</code>. <br/></td></tr>
<tr class="separator:a07c267e68ef570e9749ffed0ee581ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3027a7a3b5399a18f922c19dcef6199e"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a3027a7a3b5399a18f922c19dcef6199e"><td class="memTemplItemLeft" align="right" valign="top">Container::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a3027a7a3b5399a18f922c19dcef6199e">unconst</a> (typename Container::const_iterator i, Container &amp;)</td></tr>
<tr class="separator:a3027a7a3b5399a18f922c19dcef6199e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87e245ab29482910b90eed6b7784c7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa87e245ab29482910b90eed6b7784c7d"></a>
template&lt;typename Container1 , typename Container2 &gt; </td></tr>
<tr class="memitem:aa87e245ab29482910b90eed6b7784c7d"><td class="memTemplItemLeft" align="right" valign="top">Container2::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa87e245ab29482910b90eed6b7784c7d">ibyi</a> (typename Container1::iterator idx, Container1 &amp;ctr1, Container2 &amp;ctr2)</td></tr>
<tr class="memdesc:aa87e245ab29482910b90eed6b7784c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a const_iterator in one container into a const_iterator in another container. <br/></td></tr>
<tr class="separator:aa87e245ab29482910b90eed6b7784c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed13c6a59ee19022be7fc28df03b193"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6ed13c6a59ee19022be7fc28df03b193"></a>
template&lt;size_t NX, size_t NY, typename T &gt; </td></tr>
<tr class="memitem:ga6ed13c6a59ee19022be7fc28df03b193"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga6ed13c6a59ee19022be7fc28df03b193">load_identity</a> (<a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; NX, NY, T &gt; &amp;m)</td></tr>
<tr class="memdesc:ga6ed13c6a59ee19022be7fc28df03b193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an identity matrix in <code>m</code>. <br/></td></tr>
<tr class="separator:ga6ed13c6a59ee19022be7fc28df03b193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d4a9ae8d8fe036ba7aa8a4f1a91d51"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga09d4a9ae8d8fe036ba7aa8a4f1a91d51"></a>
template&lt;size_t NX, size_t NY, typename T &gt; </td></tr>
<tr class="memitem:ga09d4a9ae8d8fe036ba7aa8a4f1a91d51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; NY, NY, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga09d4a9ae8d8fe036ba7aa8a4f1a91d51">operator*</a> (const <a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; NX, NY, T &gt; &amp;m1, const <a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; NY, NX, T &gt; &amp;m2)</td></tr>
<tr class="memdesc:ga09d4a9ae8d8fe036ba7aa8a4f1a91d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two matrices. <br/></td></tr>
<tr class="separator:ga09d4a9ae8d8fe036ba7aa8a4f1a91d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762b10f283389600ddf4b022deb733dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga762b10f283389600ddf4b022deb733dc"></a>
template&lt;size_t NX, size_t NY, typename T &gt; </td></tr>
<tr class="memitem:ga762b10f283389600ddf4b022deb733dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; NX, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga762b10f283389600ddf4b022deb733dc">operator*</a> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; NY, T &gt; &amp;t, const <a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; NX, NY, T &gt; &amp;m)</td></tr>
<tr class="memdesc:ga762b10f283389600ddf4b022deb733dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms vector <code>t</code> with matrix <code>m</code>. <br/></td></tr>
<tr class="separator:ga762b10f283389600ddf4b022deb733dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f893785c73b84cff80ebe2e3e1a438"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga36f893785c73b84cff80ebe2e3e1a438"></a>
template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:ga36f893785c73b84cff80ebe2e3e1a438"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga36f893785c73b84cff80ebe2e3e1a438">transpose</a> (<a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; N, N, T &gt; &amp;m)</td></tr>
<tr class="memdesc:ga36f893785c73b84cff80ebe2e3e1a438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes (exchanges rows and columns) matrix <code>m</code>. <br/></td></tr>
<tr class="separator:ga36f893785c73b84cff80ebe2e3e1a438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd1c766023583b465b537dc838e4365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bd1c766023583b465b537dc838e4365"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_sse_load_matrix</b> (const float *m)</td></tr>
<tr class="separator:a2bd1c766023583b465b537dc838e4365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04101081413aae87be2b0d339d8a3a4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04101081413aae87be2b0d339d8a3a4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_sse_transform_to_vector</b> (float *result)</td></tr>
<tr class="separator:a04101081413aae87be2b0d339d8a3a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2bd6a63a12980ad1b2f7388fbf1523"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7b2bd6a63a12980ad1b2f7388fbf1523"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7b2bd6a63a12980ad1b2f7388fbf1523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; 4, float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; 4, float &gt; &amp;t, const <a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; 4, 4, float &gt; &amp;m)</td></tr>
<tr class="separator:a7b2bd6a63a12980ad1b2f7388fbf1523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a55d18d6cb8931aa9a83670779e567"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac4a55d18d6cb8931aa9a83670779e567"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac4a55d18d6cb8931aa9a83670779e567"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; 4, 4, float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; 4, 4, float &gt; &amp;m1, const <a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; 4, 4, float &gt; &amp;m2)</td></tr>
<tr class="separator:ac4a55d18d6cb8931aa9a83670779e567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87362eebe1278ce1cb7f211cb0a38b74"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga87362eebe1278ce1cb7f211cb0a38b74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga87362eebe1278ce1cb7f211cb0a38b74">construct</a> (T *p)</td></tr>
<tr class="separator:ga87362eebe1278ce1cb7f211cb0a38b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4df3bc5e05e96ba205eeba18e491e0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gaca4df3bc5e05e96ba205eeba18e491e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#gaca4df3bc5e05e96ba205eeba18e491e0">construct</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:gaca4df3bc5e05e96ba205eeba18e491e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876c801a542e93ba774df2cf7f5d23d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga876c801a542e93ba774df2cf7f5d23d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga876c801a542e93ba774df2cf7f5d23d4">construct</a> (T *p, const T &amp;value)</td></tr>
<tr class="separator:ga876c801a542e93ba774df2cf7f5d23d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36114a168a2c1c06ab0034c289005d9a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36114a168a2c1c06ab0034c289005d9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga36114a168a2c1c06ab0034c289005d9a">destroy</a> (T *p) noexcept</td></tr>
<tr class="separator:ga36114a168a2c1c06ab0034c289005d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e5c62e901b9152481b4c1fa84b9be6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2e5c62e901b9152481b4c1fa84b9be6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2e5c62e901b9152481b4c1fa84b9be6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dtors</b> (T first, T last) noexcept</td></tr>
<tr class="separator:ad2e5c62e901b9152481b4c1fa84b9be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61fa049e4c1ccc5e90f215ff2f5f883e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga61fa049e4c1ccc5e90f215ff2f5f883e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga61fa049e4c1ccc5e90f215ff2f5f883e">destroy</a> (ForwardIterator first, ForwardIterator last) noexcept</td></tr>
<tr class="separator:ga61fa049e4c1ccc5e90f215ff2f5f883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5db364264c6f35e53bedf4d05a9b047"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab5db364264c6f35e53bedf4d05a9b047"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5db364264c6f35e53bedf4d05a9b047"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ab5db364264c6f35e53bedf4d05a9b047">cast_to_type</a> (void *p, const T *)</td></tr>
<tr class="memdesc:ab5db364264c6f35e53bedf4d05a9b047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>p</code> to the type of the second pointer argument. <br/></td></tr>
<tr class="separator:ab5db364264c6f35e53bedf4d05a9b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a829166d43a2c5d0ee311730d9c741d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7a829166d43a2c5d0ee311730d9c741d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7a829166d43a2c5d0ee311730d9c741d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; T *, ptrdiff_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga7a829166d43a2c5d0ee311730d9c741d">make_temporary_buffer</a> (void *p, size_t n, const T *ptype)</td></tr>
<tr class="memdesc:ga7a829166d43a2c5d0ee311730d9c741d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary buffer pair from <code>p</code> and <code>n</code> This is intended to be used with alloca to create temporary buffers. The size in the returned pair is set to 0 if the allocation is unsuccessful. <br/></td></tr>
<tr class="separator:ga7a829166d43a2c5d0ee311730d9c741d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace908f3dbe46fb3e396f7abc2278a749"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gace908f3dbe46fb3e396f7abc2278a749"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#gace908f3dbe46fb3e396f7abc2278a749">uninitialized_copy</a> (InputIterator first, InputIterator last, ForwardIterator result)</td></tr>
<tr class="separator:gace908f3dbe46fb3e396f7abc2278a749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5b5c8751d738f522af3c888baad95a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga1b5b5c8751d738f522af3c888baad95a"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga1b5b5c8751d738f522af3c888baad95a">uninitialized_copy_n</a> (InputIterator first, size_t n, ForwardIterator result)</td></tr>
<tr class="separator:ga1b5b5c8751d738f522af3c888baad95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ffea658d144887202d59de54cbcb59"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga21ffea658d144887202d59de54cbcb59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga21ffea658d144887202d59de54cbcb59">uninitialized_fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;v)</td></tr>
<tr class="separator:ga21ffea658d144887202d59de54cbcb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bff8c10b2537716593c2aa963e2016"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga00bff8c10b2537716593c2aa963e2016"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga00bff8c10b2537716593c2aa963e2016">uninitialized_fill_n</a> (ForwardIterator first, size_t n, const T &amp;v)</td></tr>
<tr class="separator:ga00bff8c10b2537716593c2aa963e2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb0718a3783b87061c6fa10c0190457"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga2fb0718a3783b87061c6fa10c0190457"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga2fb0718a3783b87061c6fa10c0190457">accumulate</a> (InputIterator first, InputIterator last, T init)</td></tr>
<tr class="separator:ga2fb0718a3783b87061c6fa10c0190457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb49c20242b9813c7c1dacedfb24f3a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gaafb49c20242b9813c7c1dacedfb24f3a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#gaafb49c20242b9813c7c1dacedfb24f3a">accumulate</a> (InputIterator first, InputIterator last, T init, BinaryFunction binary_op)</td></tr>
<tr class="separator:gaafb49c20242b9813c7c1dacedfb24f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00f84999671b965e0c2ff0722ab99f4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:gab00f84999671b965e0c2ff0722ab99f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#gab00f84999671b965e0c2ff0722ab99f4">iota</a> (ForwardIterator first, ForwardIterator last, T value)</td></tr>
<tr class="separator:gab00f84999671b965e0c2ff0722ab99f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf694cfae81ac7ab9ad9e93ae454c4365"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename T &gt; </td></tr>
<tr class="memitem:gaf694cfae81ac7ab9ad9e93ae454c4365"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#gaf694cfae81ac7ab9ad9e93ae454c4365">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init)</td></tr>
<tr class="separator:gaf694cfae81ac7ab9ad9e93ae454c4365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f2f2f43262082c272a443d0455aa38"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename T , typename BinaryOperation1 , typename BinaryOperation2 &gt; </td></tr>
<tr class="memitem:gaa1f2f2f43262082c272a443d0455aa38"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#gaa1f2f2f43262082c272a443d0455aa38">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 sumOp, BinaryOperation2 productOp)</td></tr>
<tr class="separator:gaa1f2f2f43262082c272a443d0455aa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5195a6f6d64c3474ced728b8cf9a7f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga3b5195a6f6d64c3474ced728b8cf9a7f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga3b5195a6f6d64c3474ced728b8cf9a7f">partial_sum</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:ga3b5195a6f6d64c3474ced728b8cf9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e144b52ae1ba2d3c8c4420bd29c988b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:ga7e144b52ae1ba2d3c8c4420bd29c988b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga7e144b52ae1ba2d3c8c4420bd29c988b">partial_sum</a> (InputIterator first, InputIterator last, OutputIterator result, BinaryOperation sumOp)</td></tr>
<tr class="separator:ga7e144b52ae1ba2d3c8c4420bd29c988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc6f14fc5f65227eefb7c89d6bc9894"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga6bc6f14fc5f65227eefb7c89d6bc9894"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga6bc6f14fc5f65227eefb7c89d6bc9894">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:ga6bc6f14fc5f65227eefb7c89d6bc9894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b89120bd1c326411f6bd4ca6c4107e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:ga10b89120bd1c326411f6bd4ca6c4107e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga10b89120bd1c326411f6bd4ca6c4107e">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result, BinaryOperation differenceOp)</td></tr>
<tr class="separator:ga10b89120bd1c326411f6bd4ca6c4107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2290a44c630d1e5ca6d3da13401d3783"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2290a44c630d1e5ca6d3da13401d3783"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2290a44c630d1e5ca6d3da13401d3783"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#ga2290a44c630d1e5ca6d3da13401d3783">power</a> (T x, unsigned n)</td></tr>
<tr class="memdesc:ga2290a44c630d1e5ca6d3da13401d3783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns x^n. Donald Knuth's Russian Peasant algorithm. <br/></td></tr>
<tr class="separator:ga2290a44c630d1e5ca6d3da13401d3783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab900ea85200d128aa337ffa62c66cd23"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab900ea85200d128aa337ffa62c66cd23"></a>
template&lt;typename T , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:gab900ea85200d128aa337ffa62c66cd23"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericAlgorithms.html#gab900ea85200d128aa337ffa62c66cd23">power</a> (T x, unsigned n, BinaryOperation op)</td></tr>
<tr class="memdesc:gab900ea85200d128aa337ffa62c66cd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns x^n, using <code>op</code> instead of multiplication. Donald Knuth's Russian Peasant algorithm. <br/></td></tr>
<tr class="separator:gab900ea85200d128aa337ffa62c66cd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d390278971fa5c4a85bbd2946424ab9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d390278971fa5c4a85bbd2946424ab9"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1d390278971fa5c4a85bbd2946424ab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1d390278971fa5c4a85bbd2946424ab9">make_pair</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="memdesc:a1d390278971fa5c4a85bbd2946424ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair object with (a,b) <br/></td></tr>
<tr class="separator:a1d390278971fa5c4a85bbd2946424ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d82cdd06374a7583c61931c7af0da2a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga2d82cdd06374a7583c61931c7af0da2a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga2d82cdd06374a7583c61931c7af0da2a">copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:ga2d82cdd06374a7583c61931c7af0da2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf4cf8a14dadda237ef9dd3a1554cf2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gaacf4cf8a14dadda237ef9dd3a1554cf2"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaacf4cf8a14dadda237ef9dd3a1554cf2">find_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:gaacf4cf8a14dadda237ef9dd3a1554cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346d48aa4894f98816905f30687a2771"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga346d48aa4894f98816905f30687a2771"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga346d48aa4894f98816905f30687a2771">adjacent_find</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate p)</td></tr>
<tr class="separator:ga346d48aa4894f98816905f30687a2771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0401b8fc468f3ac943763edcf655e8fe"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga0401b8fc468f3ac943763edcf655e8fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; InputIterator, <br class="typebreak"/>
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga0401b8fc468f3ac943763edcf655e8fe">mismatch</a> (InputIterator first1, InputIterator last1, InputIterator first2, BinaryPredicate comp)</td></tr>
<tr class="separator:ga0401b8fc468f3ac943763edcf655e8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c1b1932954a8e497aef7933d1e579f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga44c1b1932954a8e497aef7933d1e579f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga44c1b1932954a8e497aef7933d1e579f">equal</a> (InputIterator first1, InputIterator last1, InputIterator first2, BinaryPredicate comp)</td></tr>
<tr class="separator:ga44c1b1932954a8e497aef7933d1e579f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb8e059c559a49beb7e378f7302e393"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga8eb8e059c559a49beb7e378f7302e393"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga8eb8e059c559a49beb7e378f7302e393">count_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:ga8eb8e059c559a49beb7e378f7302e393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be4f14f257892bea1de2b62c0b3e7eb"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga3be4f14f257892bea1de2b62c0b3e7eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga3be4f14f257892bea1de2b62c0b3e7eb">replace_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga3be4f14f257892bea1de2b62c0b3e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727911bd639a35693bae5323c8ad959f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga727911bd639a35693bae5323c8ad959f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga727911bd639a35693bae5323c8ad959f">replace_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga727911bd639a35693bae5323c8ad959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bae5360b2a20cf93f08b7e13e05d381"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga0bae5360b2a20cf93f08b7e13e05d381"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga0bae5360b2a20cf93f08b7e13e05d381">remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:ga0bae5360b2a20cf93f08b7e13e05d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1ead56b32be0d1d96e32e309df8c1e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gaeb1ead56b32be0d1d96e32e309df8c1e"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaeb1ead56b32be0d1d96e32e309df8c1e">remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr class="separator:gaeb1ead56b32be0d1d96e32e309df8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795c5ecc643391dce42902af44c4ea47"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga795c5ecc643391dce42902af44c4ea47"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga795c5ecc643391dce42902af44c4ea47">unique_copy</a> (InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga795c5ecc643391dce42902af44c4ea47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242ed2f1914479018c8885ee8bf6becb"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga242ed2f1914479018c8885ee8bf6becb"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga242ed2f1914479018c8885ee8bf6becb">unique</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga242ed2f1914479018c8885ee8bf6becb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2a5ea22968a897e97ca4703c432985"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga6c2a5ea22968a897e97ca4703c432985"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6c2a5ea22968a897e97ca4703c432985">lower_bound</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:ga6c2a5ea22968a897e97ca4703c432985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7ddac748bd3e1f6f1580eff6cce363"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaca7ddac748bd3e1f6f1580eff6cce363"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaca7ddac748bd3e1f6f1580eff6cce363">binary_search</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:gaca7ddac748bd3e1f6f1580eff6cce363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032">upper_bound</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9dc80f99a56ac75288aff4331aea16f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gac9dc80f99a56ac75288aff4331aea16f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; ForwardIterator, <br class="typebreak"/>
ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gac9dc80f99a56ac75288aff4331aea16f">equal_range</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:gac9dc80f99a56ac75288aff4331aea16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a41f73516ec79de898d9354e821dc8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga33a41f73516ec79de898d9354e821dc8"></a>
template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga33a41f73516ec79de898d9354e821dc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga33a41f73516ec79de898d9354e821dc8">nth_element</a> (RandomAccessIterator first, RandomAccessIterator, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="memdesc:ga33a41f73516ec79de898d9354e821dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts <code>nth</code> element into its sorted position. In this implementation, the entire array is sorted. The performance difference is so small and the function use is so rare, there is no need to have code for it. <br/></td></tr>
<tr class="separator:ga33a41f73516ec79de898d9354e821dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga86388ce8fdc1bd169e3a8ee73f53dd16"></a>
template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga86388ce8fdc1bd169e3a8ee73f53dd16">search</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first subsequence [first2,last2) in [first1,last1) <br/></td></tr>
<tr class="separator:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga32a5498df6616b7d23c60f45c1df2fb7"></a>
template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga32a5498df6616b7d23c60f45c1df2fb7">find_end</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last subsequence [first2,last2) in [first1,last1) <br/></td></tr>
<tr class="separator:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaecbcfd9b6437bb34583ad2ec950ad414"></a>
template&lt;typename Iterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaecbcfd9b6437bb34583ad2ec950ad414">search_n</a> (Iterator first, Iterator last, size_t <a class="el" href="group__SearchingAlgorithms.html#ga7215ebfa66a197fb66a111d74390ffb5">count</a>, const T &amp;value, BinaryPredicate comp)</td></tr>
<tr class="memdesc:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurence of <code>count</code> <code>values</code> in [first, last) <br/></td></tr>
<tr class="separator:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7a7e870ab3b0e6a74ad8397c0a3e40e4"></a>
template&lt;typename InputIterator , typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga7a7e870ab3b0e6a74ad8397c0a3e40e4">find_first_of</a> (InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches [first1,last1) for the first occurrence of an element from [first2,last2) <br/></td></tr>
<tr class="separator:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51634d6a0289343be2738141ce61760"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf51634d6a0289343be2738141ce61760"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaf51634d6a0289343be2738141ce61760"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaf51634d6a0289343be2738141ce61760">includes</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gaf51634d6a0289343be2738141ce61760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if [first2,last2) is a subset of [first1,last1) <br/></td></tr>
<tr class="separator:gaf51634d6a0289343be2738141ce61760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18fe33a30effaf461623c701a8770b51"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga18fe33a30effaf461623c701a8770b51"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga18fe33a30effaf461623c701a8770b51">set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga18fe33a30effaf461623c701a8770b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges [first1,last1) with [first2,last2)  <a href="group__PredicateAlgorithms.html#ga18fe33a30effaf461623c701a8770b51">More...</a><br/></td></tr>
<tr class="separator:ga18fe33a30effaf461623c701a8770b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c343a402644f4be865d97d23348a578"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6c343a402644f4be865d97d23348a578"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga6c343a402644f4be865d97d23348a578"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6c343a402644f4be865d97d23348a578">set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga6c343a402644f4be865d97d23348a578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set containing elements shared by the given ranges. <br/></td></tr>
<tr class="separator:ga6c343a402644f4be865d97d23348a578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf12f1c23baeff1f70ff80f1cd436c6c9"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaf12f1c23baeff1f70ff80f1cd436c6c9">set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from [first1,last1) elements present in [first2,last2) <br/></td></tr>
<tr class="separator:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga71951a9e5ab78fe83d062b3309b5e7be"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga71951a9e5ab78fe83d062b3309b5e7be">set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs union of sets A-B and B-A. <br/></td></tr>
<tr class="separator:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1c0ddb258f2f12f9377293633f6ab0b9"></a>
template&lt;typename ForwardIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga1c0ddb258f2f12f9377293633f6ab0b9">is_sorted</a> (ForwardIterator first, ForwardIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given range is sorted. <br/></td></tr>
<tr class="separator:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0cc6d13188604ee1f39977e9b5e0e9e1"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga0cc6d13188604ee1f39977e9b5e0e9e1">lexicographical_compare</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two given containers like strcmp compares strings. <br/></td></tr>
<tr class="separator:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9d4585285b0b96d7f21a4923b747c2dd"></a>
template&lt;typename BidirectionalIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga9d4585285b0b96d7f21a4923b747c2dd">next_permutation</a> (BidirectionalIterator first, BidirectionalIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the next lexicographical permutation of [first,last). Returns false if no further permutations can be created. <br/></td></tr>
<tr class="separator:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae060c050cb83e758b79cf6e447d1b82c"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae060c050cb83e758b79cf6e447d1b82c"></a>
template&lt;typename BidirectionalIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gae060c050cb83e758b79cf6e447d1b82c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gae060c050cb83e758b79cf6e447d1b82c">prev_permutation</a> (BidirectionalIterator first, BidirectionalIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gae060c050cb83e758b79cf6e447d1b82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the previous lexicographical permutation of [first,last). Returns false if no further permutations can be created. <br/></td></tr>
<tr class="separator:gae060c050cb83e758b79cf6e447d1b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc49d8f4515858066a500225cd5d213"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4dc49d8f4515858066a500225cd5d213"></a>
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4dc49d8f4515858066a500225cd5d213"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga4dc49d8f4515858066a500225cd5d213">max_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga4dc49d8f4515858066a500225cd5d213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the max element in [first,last) <br/></td></tr>
<tr class="separator:ga4dc49d8f4515858066a500225cd5d213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae8f424b822565092533dda5b65b06d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8ae8f424b822565092533dda5b65b06d"></a>
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga8ae8f424b822565092533dda5b65b06d"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga8ae8f424b822565092533dda5b65b06d">min_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga8ae8f424b822565092533dda5b65b06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the min element in [first,last) <br/></td></tr>
<tr class="separator:ga8ae8f424b822565092533dda5b65b06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga44ac4cdee5ab5bb32aea40cd92f6bdcd"></a>
template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga44ac4cdee5ab5bb32aea40cd92f6bdcd">partial_sort</a> (RandomAccessIterator first, RandomAccessIterator, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes [first,middle) a part of the sorted array. Contents of [middle,last) is undefined. This implementation just calls stable_sort. <br/></td></tr>
<tr class="separator:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaca13a8df57cfc9d9a84da2477d3f1bc0"></a>
template&lt;typename InputIterator , typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaca13a8df57cfc9d9a84da2477d3f1bc0">partial_sort_copy</a> (InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like partial_sort, but outputs to [result_first,result_last) <br/></td></tr>
<tr class="separator:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c63d621e94fda2bca1c215d51f2f36"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga34c63d621e94fda2bca1c215d51f2f36"></a>
template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga34c63d621e94fda2bca1c215d51f2f36"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga34c63d621e94fda2bca1c215d51f2f36">stable_partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr class="memdesc:ga34c63d621e94fda2bca1c215d51f2f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like partition, but preserves equal element order. <br/></td></tr>
<tr class="separator:ga34c63d621e94fda2bca1c215d51f2f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35be65dae1fb327c8d5e2421689dd074"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga35be65dae1fb327c8d5e2421689dd074"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga35be65dae1fb327c8d5e2421689dd074">partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr class="memdesc:ga35be65dae1fb327c8d5e2421689dd074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits [first,last) in two by <code>pred</code>.  <a href="group__PredicateAlgorithms.html#ga35be65dae1fb327c8d5e2421689dd074">More...</a><br/></td></tr>
<tr class="separator:ga35be65dae1fb327c8d5e2421689dd074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295d29522edb41f66b2f9ee1aa445cd0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a295d29522edb41f66b2f9ee1aa445cd0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a295d29522edb41f66b2f9ee1aa445cd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classustl_1_1cmemlink.html">cmemlink</a> &amp;a, <a class="el" href="classustl_1_1cmemlink.html">cmemlink</a> &amp;b)</td></tr>
<tr class="separator:a295d29522edb41f66b2f9ee1aa445cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af28e925356bec352a02d926a41298f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9af28e925356bec352a02d926a41298f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9af28e925356bec352a02d926a41298f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classustl_1_1memlink.html">memlink</a> &amp;a, <a class="el" href="classustl_1_1memlink.html">memlink</a> &amp;b)</td></tr>
<tr class="separator:a9af28e925356bec352a02d926a41298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742a7af5ca3c94b02e4c4db930745969"><td class="memTemplParams" colspan="2"><a class="anchor" id="a742a7af5ca3c94b02e4c4db930745969"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a742a7af5ca3c94b02e4c4db930745969"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classustl_1_1memblock.html">memblock</a> &amp;a, <a class="el" href="classustl_1_1memblock.html">memblock</a> &amp;b)</td></tr>
<tr class="separator:a742a7af5ca3c94b02e4c4db930745969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff1f8856f0c1e345f5204bb90cba00d"><td class="memTemplParams" colspan="2"><a class="anchor" id="acff1f8856f0c1e345f5204bb90cba00d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acff1f8856f0c1e345f5204bb90cba00d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classustl_1_1string.html">string</a> &amp;a, <a class="el" href="classustl_1_1string.html">string</a> &amp;b)</td></tr>
<tr class="separator:acff1f8856f0c1e345f5204bb90cba00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21848e18695d14af5c04f468a2c30358"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21848e18695d14af5c04f468a2c30358"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEMPLATE_SWAP_PSPEC</b> (TEMPLATE_TYPE1(<a class="el" href="classustl_1_1vector.html">vector</a>, T), TEMPLATE_DECL1(T)) TEMPLATE_SWAP_PSPEC(TEMPLATE_TYPE1(<a class="el" href="classustl_1_1set.html">set</a></td></tr>
<tr class="separator:a21848e18695d14af5c04f468a2c30358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598d566351080cd05288e8adb60f197e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a598d566351080cd05288e8adb60f197e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEMPLATE_DECL1</b> (T)) TEMPLATE_SWAP_PSPEC(TEMPLATE_TYPE1(<a class="el" href="classustl_1_1multiset.html">multiset</a></td></tr>
<tr class="separator:a598d566351080cd05288e8adb60f197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2112bf4fcd110e23994a10be9a043d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc2112bf4fcd110e23994a10be9a043d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#acc2112bf4fcd110e23994a10be9a043d">TEMPLATE_FULL_DECL2</a> (size_t, N, typename, T)) template&lt; typename T1</td></tr>
<tr class="memdesc:acc2112bf4fcd110e23994a10be9a043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads pair <code>p</code> from stream <code>is</code>. <br/></td></tr>
<tr class="separator:acc2112bf4fcd110e23994a10be9a043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60739cd3370a86bc2856f0f98e49f16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae60739cd3370a86bc2856f0f98e49f16"></a>
T2 <a class="el" href="classustl_1_1istream.html">istream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classustl_1_1istream.html">istream</a> &amp;is, <a class="el" href="classustl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="separator:ae60739cd3370a86bc2856f0f98e49f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376a8a66f9a3eee6fe80f74da60b90f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a376a8a66f9a3eee6fe80f74da60b90f3"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a376a8a66f9a3eee6fe80f74da60b90f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a376a8a66f9a3eee6fe80f74da60b90f3">operator&lt;&lt;</a> (<a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;os, const <a class="el" href="classustl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="memdesc:a376a8a66f9a3eee6fe80f74da60b90f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes pair <code>p</code> to stream <code>os</code>. <br/></td></tr>
<tr class="separator:a376a8a66f9a3eee6fe80f74da60b90f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5225d4a9ee528196402690f076cfe172"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5225d4a9ee528196402690f076cfe172"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5225d4a9ee528196402690f076cfe172"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a5225d4a9ee528196402690f076cfe172">operator&lt;&lt;</a> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const <a class="el" href="classustl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="memdesc:a5225d4a9ee528196402690f076cfe172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes pair <code>p</code> to stream <code>os</code>. <br/></td></tr>
<tr class="separator:a5225d4a9ee528196402690f076cfe172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be038c5b6763b3fc76ec48e7a212187"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3be038c5b6763b3fc76ec48e7a212187"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a3be038c5b6763b3fc76ec48e7a212187"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1pair.html">pair</a>&lt; typename <br class="typebreak"/>
Container::iterator, typename <br class="typebreak"/>
Container::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a3be038c5b6763b3fc76ec48e7a212187">unconst</a> (const <a class="el" href="classustl_1_1pair.html">pair</a>&lt; typename Container::const_iterator, typename Container::const_iterator &gt; &amp;i, Container &amp;)</td></tr>
<tr class="memdesc:a3be038c5b6763b3fc76ec48e7a212187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a const_iterator pair into an iterator pair Useful for converting pair ranges returned by equal_range, for instance. This is an extension, available in uSTL. <br/></td></tr>
<tr class="separator:a3be038c5b6763b3fc76ec48e7a212187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fbe04e1eba8ca14c2ded85e1221f69"><td class="memTemplParams" colspan="2"><a class="anchor" id="a02fbe04e1eba8ca14c2ded85e1221f69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02fbe04e1eba8ca14c2ded85e1221f69"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_align_of</b> (const <a class="el" href="classustl_1_1vector.html">vector</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a02fbe04e1eba8ca14c2ded85e1221f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02078397e1c329f64cf0d86e2ddd172d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a02078397e1c329f64cf0d86e2ddd172d"></a>
template&lt;size_t Size&gt; </td></tr>
<tr class="memitem:a02078397e1c329f64cf0d86e2ddd172d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1istringstream.html">istringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a02078397e1c329f64cf0d86e2ddd172d">operator&gt;&gt;</a> (<a class="el" href="classustl_1_1istringstream.html">istringstream</a> &amp;is, <a class="el" href="classustl_1_1bitset.html">bitset</a>&lt; Size &gt; &amp;v)</td></tr>
<tr class="memdesc:a02078397e1c329f64cf0d86e2ddd172d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes bitset <code>v</code> into stream <code>os</code>. <br/></td></tr>
<tr class="separator:a02078397e1c329f64cf0d86e2ddd172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2480f2e1c41a9470dd9230967c34bfb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2480f2e1c41a9470dd9230967c34bfb"></a>
template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:ad2480f2e1c41a9470dd9230967c34bfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1istream.html">istream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classustl_1_1istream.html">istream</a> &amp;is, <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:ad2480f2e1c41a9470dd9230967c34bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dd95590d55cdb4e8ca67ef6aa3aea0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4dd95590d55cdb4e8ca67ef6aa3aea0"></a>
template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:ab4dd95590d55cdb4e8ca67ef6aa3aea0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classustl_1_1ostream.html">ostream</a> &amp;os, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:ab4dd95590d55cdb4e8ca67ef6aa3aea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e5f3c8e76a4c957eb15b5abf22257c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67e5f3c8e76a4c957eb15b5abf22257c"></a>
template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:a67e5f3c8e76a4c957eb15b5abf22257c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:a67e5f3c8e76a4c957eb15b5abf22257c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f297ff7e398016759671b82240927a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f297ff7e398016759671b82240927a6"></a>
template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:a7f297ff7e398016759671b82240927a6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_align_of</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="separator:a7f297ff7e398016759671b82240927a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23da4b9259b097e962dc0a2d7a0ff07c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a23da4b9259b097e962dc0a2d7a0ff07c"></a>
template&lt;typename T , typename IntT &gt; </td></tr>
<tr class="memitem:a23da4b9259b097e962dc0a2d7a0ff07c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chartype_text_write</b> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const T &amp;v)</td></tr>
<tr class="separator:a23da4b9259b097e962dc0a2d7a0ff07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eaa3bc28afd565324c691ac729a9f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1eaa3bc28afd565324c691ac729a9f4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae1eaa3bc28afd565324c691ac729a9f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>container_element_text_write</b> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const uint8_t &amp;v)</td></tr>
<tr class="separator:ae1eaa3bc28afd565324c691ac729a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f453c8c3ecb58defc535ec667cf03d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9f453c8c3ecb58defc535ec667cf03d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac9f453c8c3ecb58defc535ec667cf03d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>container_element_text_write</b> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const int8_t &amp;v)</td></tr>
<tr class="separator:ac9f453c8c3ecb58defc535ec667cf03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa816b01a3a32ebc130197da70ca13625"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa816b01a3a32ebc130197da70ca13625"></a>
template&lt;size_t NX, size_t NY, typename T &gt; </td></tr>
<tr class="memitem:aa816b01a3a32ebc130197da70ca13625"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa816b01a3a32ebc130197da70ca13625">operator&lt;&lt;</a> (<a class="el" href="classustl_1_1ostringstream.html">ostringstream</a> &amp;os, const <a class="el" href="classustl_1_1matrix.html">matrix</a>&lt; NX, NY, T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa816b01a3a32ebc130197da70ca13625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes tuple <code>v</code> into stream <code>os</code>. <br/></td></tr>
<tr class="separator:aa816b01a3a32ebc130197da70ca13625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ff48cf37a68c961634b834d447e41d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ff48cf37a68c961634b834d447e41d"></a>
<a class="el" href="classustl_1_1__long4grain.html">_long4grain</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a09ff48cf37a68c961634b834d447e41d">long4grain</a> (unsigned long &amp;v)</td></tr>
<tr class="memdesc:a09ff48cf37a68c961634b834d447e41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap long values to allow writing them on 4-grain even on 64bit platforms. <br/></td></tr>
<tr class="separator:a09ff48cf37a68c961634b834d447e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7738541a49fc9ae033b13f33483d88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b7738541a49fc9ae033b13f33483d88"></a>
const <a class="el" href="classustl_1_1__long4grain.html">_long4grain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1b7738541a49fc9ae033b13f33483d88">long4grain</a> (const unsigned long &amp;v)</td></tr>
<tr class="memdesc:a1b7738541a49fc9ae033b13f33483d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap long values to allow writing them on 4-grain even on 64bit platforms. <br/></td></tr>
<tr class="separator:a1b7738541a49fc9ae033b13f33483d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e48298f6f27671fb0c6b6db25f62987"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e48298f6f27671fb0c6b6db25f62987"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e48298f6f27671fb0c6b6db25f62987"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1__long4grain.html">_long4grain</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a3e48298f6f27671fb0c6b6db25f62987">ptr4grain</a> (T *&amp;p)</td></tr>
<tr class="memdesc:a3e48298f6f27671fb0c6b6db25f62987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap pointer values to allow writing them on 4-grain even on 64bit platforms. <br/></td></tr>
<tr class="separator:a3e48298f6f27671fb0c6b6db25f62987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4892e3b35386f3e64a389dbfdd115c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4892e3b35386f3e64a389dbfdd115c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4892e3b35386f3e64a389dbfdd115c6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classustl_1_1__long4grain.html">_long4grain</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ab4892e3b35386f3e64a389dbfdd115c6">ptr4grain</a> (const T *const &amp;p)</td></tr>
<tr class="memdesc:ab4892e3b35386f3e64a389dbfdd115c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap pointer values to allow writing them on 4-grain even on 64bit platforms. <br/></td></tr>
<tr class="separator:ab4892e3b35386f3e64a389dbfdd115c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92e99b044149a3d989dbc738e6040f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab92e99b044149a3d989dbc738e6040f6"></a>
<a class="el" href="classustl_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const char *cs, const <a class="el" href="classustl_1_1string.html">string</a> &amp;ss)</td></tr>
<tr class="separator:ab92e99b044149a3d989dbc738e6040f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65576f2ba808b0b7a9fcd6c9be88e4fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65576f2ba808b0b7a9fcd6c9be88e4fa"></a>
hashvalue_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const char *first, const char *last)</td></tr>
<tr class="separator:a65576f2ba808b0b7a9fcd6c9be88e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77edbc2bcb78cfe8b6a7497ed51ff264"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77edbc2bcb78cfe8b6a7497ed51ff264"></a>
hashvalue_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const char *v)</td></tr>
<tr class="separator:a77edbc2bcb78cfe8b6a7497ed51ff264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7af134c7e8967867e33545e499d0ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed7af134c7e8967867e33545e499d0ca"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aed7af134c7e8967867e33545e499d0ca">Utf8Bytes</a> (wchar_t v)</td></tr>
<tr class="memdesc:aed7af134c7e8967867e33545e499d0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes required to UTF-8 encode <code>v</code>. <br/></td></tr>
<tr class="separator:aed7af134c7e8967867e33545e499d0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a088367acbb89a5c5a46b52f792afb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28a088367acbb89a5c5a46b52f792afb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a28a088367acbb89a5c5a46b52f792afb">Utf8Bytes</a> (const wchar_t *first, const wchar_t *last)</td></tr>
<tr class="memdesc:a28a088367acbb89a5c5a46b52f792afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the size of a wchar_t array in UTF-8 encoding. <br/></td></tr>
<tr class="separator:a28a088367acbb89a5c5a46b52f792afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0243cfe6f82ffa98d0b69e0a22319c88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0243cfe6f82ffa98d0b69e0a22319c88"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a0243cfe6f82ffa98d0b69e0a22319c88">Utf8SequenceBytes</a> (wchar_t c)</td></tr>
<tr class="memdesc:a0243cfe6f82ffa98d0b69e0a22319c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes in a UTF-8 sequence that starts with <code>c</code>. <br/></td></tr>
<tr class="separator:a0243cfe6f82ffa98d0b69e0a22319c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f19399e4f98e418e77f3fe4cbaab247"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f19399e4f98e418e77f3fe4cbaab247"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3f19399e4f98e418e77f3fe4cbaab247"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1utf8out__iterator.html">utf8out_iterator</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a3f19399e4f98e418e77f3fe4cbaab247">utf8out</a> (Iterator i)</td></tr>
<tr class="memdesc:a3f19399e4f98e418e77f3fe4cbaab247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UTF-8 adaptor writing to <code>i</code>. Useful in conjuction with <a class="el" href="classustl_1_1back__insert__iterator.html" title="Calls push_back on bound container for each assignment. ">back_insert_iterator</a>. <br/></td></tr>
<tr class="separator:a3f19399e4f98e418e77f3fe4cbaab247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcca7186285ae338b8e27f62a73f779"><td class="memTemplParams" colspan="2"><a class="anchor" id="abfcca7186285ae338b8e27f62a73f779"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:abfcca7186285ae338b8e27f62a73f779"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1utf8in__iterator.html">utf8in_iterator</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#abfcca7186285ae338b8e27f62a73f779">utf8in</a> (Iterator i)</td></tr>
<tr class="memdesc:abfcca7186285ae338b8e27f62a73f779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UTF-8 adaptor reading from <code>i</code>. <br/></td></tr>
<tr class="separator:abfcca7186285ae338b8e27f62a73f779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dcb7ff180f287aa10fbf6a88160394"><td class="memTemplParams" colspan="2"><a class="anchor" id="a39dcb7ff180f287aa10fbf6a88160394"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a39dcb7ff180f287aa10fbf6a88160394"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a39dcb7ff180f287aa10fbf6a88160394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fede2bca2940967b12f8859d63e607f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3fede2bca2940967b12f8859d63e607f"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3fede2bca2940967b12f8859d63e607f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a3fede2bca2940967b12f8859d63e607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a865eac5a8128439224933911edeab5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0a865eac5a8128439224933911edeab5"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0a865eac5a8128439224933911edeab5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (<a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a0a865eac5a8128439224933911edeab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd09931b451582a435e7ab2d0359c06"><td class="memTemplParams" colspan="2"><a class="anchor" id="aefd09931b451582a435e7ab2d0359c06"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aefd09931b451582a435e7ab2d0359c06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (<a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:aefd09931b451582a435e7ab2d0359c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6845fa4ec4d55ad70cdb0aff4890e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d6845fa4ec4d55ad70cdb0aff4890e0"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1d6845fa4ec4d55ad70cdb0aff4890e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a1d6845fa4ec4d55ad70cdb0aff4890e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600b3230fe804261beb4ed2f289760c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6600b3230fe804261beb4ed2f289760c"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6600b3230fe804261beb4ed2f289760c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (<a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a6600b3230fe804261beb4ed2f289760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827103dd719ab6150c26c48472033909"><td class="memTemplParams" colspan="2"><a class="anchor" id="a827103dd719ab6150c26c48472033909"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a827103dd719ab6150c26c48472033909"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a827103dd719ab6150c26c48472033909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade81c3da2b46ec1bdedddd40398dc058"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade81c3da2b46ec1bdedddd40398dc058"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ade81c3da2b46ec1bdedddd40398dc058"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:ade81c3da2b46ec1bdedddd40398dc058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2759cc77da1db741b44a4cdb7534a6ab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2759cc77da1db741b44a4cdb7534a6ab"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2759cc77da1db741b44a4cdb7534a6ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a2759cc77da1db741b44a4cdb7534a6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044dfc9e9e90cc41f317051ff899b50b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a044dfc9e9e90cc41f317051ff899b50b"></a>
template&lt;size_t N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a044dfc9e9e90cc41f317051ff899b50b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T1 &gt; &amp;t1, const <a class="el" href="classustl_1_1tuple.html">tuple</a>&lt; N, T2 &gt; &amp;t2)</td></tr>
<tr class="separator:a044dfc9e9e90cc41f317051ff899b50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682663ec9ec63d569d30fbe55beca2f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a682663ec9ec63d569d30fbe55beca2f9"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a682663ec9ec63d569d30fbe55beca2f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a682663ec9ec63d569d30fbe55beca2f9">VectorEnd</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:a682663ec9ec63d569d30fbe55beca2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end() for a static vector. <br/></td></tr>
<tr class="separator:a682663ec9ec63d569d30fbe55beca2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e712dd6676c1b2a805c05cc412484f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97e712dd6676c1b2a805c05cc412484f"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a97e712dd6676c1b2a805c05cc412484f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a97e712dd6676c1b2a805c05cc412484f">min</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a97e712dd6676c1b2a805c05cc412484f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of <code>a</code> and <code>b</code>. <br/></td></tr>
<tr class="separator:a97e712dd6676c1b2a805c05cc412484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c31c98136c275966fbd8e24e23ae1f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c31c98136c275966fbd8e24e23ae1f7"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7c31c98136c275966fbd8e24e23ae1f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a7c31c98136c275966fbd8e24e23ae1f7">max</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a7c31c98136c275966fbd8e24e23ae1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of <code>a</code> and <code>b</code>. <br/></td></tr>
<tr class="separator:a7c31c98136c275966fbd8e24e23ae1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b10e0f388002924ccc1835082145a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a30b10e0f388002924ccc1835082145a4"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a30b10e0f388002924ccc1835082145a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a30b10e0f388002924ccc1835082145a4">VectorElement</a> (T(&amp;v)[N], size_t i)</td></tr>
<tr class="memdesc:a30b10e0f388002924ccc1835082145a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexes into a static array with bounds limit. <br/></td></tr>
<tr class="separator:a30b10e0f388002924ccc1835082145a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212837153937180d6a84a3fe07c4f640"><td class="memTemplParams" colspan="2"><a class="anchor" id="a212837153937180d6a84a3fe07c4f640"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a212837153937180d6a84a3fe07c4f640"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a212837153937180d6a84a3fe07c4f640">AlignDown</a> (T n, size_t grain=<a class="el" href="namespaceustl.html#a8a1660fbafffddb5b06253d05b6df760">c_DefaultAlignment</a>)</td></tr>
<tr class="memdesc:a212837153937180d6a84a3fe07c4f640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds <code>n</code> up to be divisible by <code>grain</code>. <br/></td></tr>
<tr class="separator:a212837153937180d6a84a3fe07c4f640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39742f00eac8232568d7c124097aca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b39742f00eac8232568d7c124097aca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b39742f00eac8232568d7c124097aca"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a9b39742f00eac8232568d7c124097aca">Align</a> (T n, size_t grain=<a class="el" href="namespaceustl.html#a8a1660fbafffddb5b06253d05b6df760">c_DefaultAlignment</a>)</td></tr>
<tr class="memdesc:a9b39742f00eac8232568d7c124097aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds <code>n</code> up to be divisible by <code>grain</code>. <br/></td></tr>
<tr class="separator:a9b39742f00eac8232568d7c124097aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b6387875022f310d1d128bf25480ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a39b6387875022f310d1d128bf25480ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39b6387875022f310d1d128bf25480ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a39b6387875022f310d1d128bf25480ca">NullPointer</a> (void)</td></tr>
<tr class="memdesc:a39b6387875022f310d1d128bf25480ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL pointer cast to T. <br/></td></tr>
<tr class="separator:a39b6387875022f310d1d128bf25480ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad818c99105faa4a68f55d519a89db505"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad818c99105faa4a68f55d519a89db505"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad818c99105faa4a68f55d519a89db505"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ad818c99105faa4a68f55d519a89db505">NullValue</a> (void)</td></tr>
<tr class="memdesc:ad818c99105faa4a68f55d519a89db505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-dereferentiable value reference. This is useful for passing to stream_align_of or the like which need a value but don't need to actually use it. <br/></td></tr>
<tr class="separator:ad818c99105faa4a68f55d519a89db505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082b5d5dcac34db043cd212a6f830ca8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a082b5d5dcac34db043cd212a6f830ca8"></a>
template&lt;typename T , typename Distance &gt; </td></tr>
<tr class="memitem:a082b5d5dcac34db043cd212a6f830ca8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a082b5d5dcac34db043cd212a6f830ca8">advance</a> (T i, Distance offset)</td></tr>
<tr class="memdesc:a082b5d5dcac34db043cd212a6f830ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets an iterator. <br/></td></tr>
<tr class="separator:a082b5d5dcac34db043cd212a6f830ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f6c55519656f92212f72aec9916c03"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3f6c55519656f92212f72aec9916c03"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa3f6c55519656f92212f72aec9916c03"><td class="memTemplItemLeft" align="right" valign="top">constexpr ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa3f6c55519656f92212f72aec9916c03">distance</a> (T1 i1, T2 i2)</td></tr>
<tr class="memdesc:aa3f6c55519656f92212f72aec9916c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference <code>p1</code> - <code>p2</code>. <br/></td></tr>
<tr class="separator:aa3f6c55519656f92212f72aec9916c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1cf2ae964870f20ab96c53fcd2a9a0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ae1cf2ae964870f20ab96c53fcd2a9a0e">absv</a> (T v)</td></tr>
<tr class="memdesc:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of <code>v</code> Unlike the stdlib functions, this is inline and works with all types. <br/></td></tr>
<tr class="separator:ae1cf2ae964870f20ab96c53fcd2a9a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a185ef880ee8ddb99b8789df5ef7ef49f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a185ef880ee8ddb99b8789df5ef7ef49f">sign</a> (T v)</td></tr>
<tr class="memdesc:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -1 for negative values, 1 for positive, and 0 for 0. <br/></td></tr>
<tr class="separator:a185ef880ee8ddb99b8789df5ef7ef49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c86fef85e5eaa8fde86a58614099e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d0c86fef85e5eaa8fde86a58614099e"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1d0c86fef85e5eaa8fde86a58614099e"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1d0c86fef85e5eaa8fde86a58614099e">abs_distance</a> (T1 i1, T2 i2)</td></tr>
<tr class="memdesc:a1d0c86fef85e5eaa8fde86a58614099e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the distance i1 and i2. <br/></td></tr>
<tr class="separator:a1d0c86fef85e5eaa8fde86a58614099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49903aef740bceb8d4ff984de839d9f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49903aef740bceb8d4ff984de839d9f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49903aef740bceb8d4ff984de839d9f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a49903aef740bceb8d4ff984de839d9f3">size_of_elements</a> (size_t n, const T *)</td></tr>
<tr class="memdesc:a49903aef740bceb8d4ff984de839d9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of <code>n</code> elements of size <code>T</code>. <br/></td></tr>
<tr class="separator:a49903aef740bceb8d4ff984de839d9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011e13fddd1c6c10d703c4b3f8f76809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a011e13fddd1c6c10d703c4b3f8f76809"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>bswap_16</b> (uint16_t v)</td></tr>
<tr class="separator:a011e13fddd1c6c10d703c4b3f8f76809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c4ec5b3ba9d6946187ee7a88862f1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82c4ec5b3ba9d6946187ee7a88862f1e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>bswap_32</b> (uint32_t v)</td></tr>
<tr class="separator:a82c4ec5b3ba9d6946187ee7a88862f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf45476dd30b40810240775c9b1c656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbf45476dd30b40810240775c9b1c656"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>bswap_64</b> (uint64_t v)</td></tr>
<tr class="separator:afbf45476dd30b40810240775c9b1c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb8996e66254e65468eae028c8f599"><td class="memTemplParams" colspan="2"><a class="anchor" id="acccb8996e66254e65468eae028c8f599"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acccb8996e66254e65468eae028c8f599"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#acccb8996e66254e65468eae028c8f599">bswap</a> (const T &amp;v)</td></tr>
<tr class="memdesc:acccb8996e66254e65468eae028c8f599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byteorder of <code>v</code>. <br/></td></tr>
<tr class="separator:acccb8996e66254e65468eae028c8f599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc02774aa67eb470e3da31243c03c8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44bc02774aa67eb470e3da31243c03c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44bc02774aa67eb470e3da31243c03c8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>le_to_native</b> (const T &amp;v)</td></tr>
<tr class="separator:a44bc02774aa67eb470e3da31243c03c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dec89857583920ea685a7d776b6145"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98dec89857583920ea685a7d776b6145"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98dec89857583920ea685a7d776b6145"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>be_to_native</b> (const T &amp;v)</td></tr>
<tr class="separator:a98dec89857583920ea685a7d776b6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd520bcceef5c0d2d24180accc963e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6cd520bcceef5c0d2d24180accc963e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd520bcceef5c0d2d24180accc963e7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>native_to_le</b> (const T &amp;v)</td></tr>
<tr class="separator:a6cd520bcceef5c0d2d24180accc963e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb86deacdf9d2d01df702dc8b5961208"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb86deacdf9d2d01df702dc8b5961208"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb86deacdf9d2d01df702dc8b5961208"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>native_to_be</b> (const T &amp;v)</td></tr>
<tr class="separator:adb86deacdf9d2d01df702dc8b5961208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa36c7bb72d2ee3590f26f8dd3c9b8b6a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa36c7bb72d2ee3590f26f8dd3c9b8b6a">Delete</a> (T *&amp;p)</td></tr>
<tr class="memdesc:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>p</code> and sets it to NULL. <br/></td></tr>
<tr class="separator:aa36c7bb72d2ee3590f26f8dd3c9b8b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689f2db55308f0b38467e3d4c251ca8a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a689f2db55308f0b38467e3d4c251ca8a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a689f2db55308f0b38467e3d4c251ca8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a689f2db55308f0b38467e3d4c251ca8a">DeleteVector</a> (T *&amp;p)</td></tr>
<tr class="memdesc:a689f2db55308f0b38467e3d4c251ca8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>p</code> as an array and sets it to NULL. <br/></td></tr>
<tr class="separator:a689f2db55308f0b38467e3d4c251ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9188c144f6085dc6bf05b69b9c3a11b8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a9188c144f6085dc6bf05b69b9c3a11b8">operator!=</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making != from ! and ==. <br/></td></tr>
<tr class="separator:a9188c144f6085dc6bf05b69b9c3a11b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c8fa4b3b83567aa2c94df6a8d99b917"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a2c8fa4b3b83567aa2c94df6a8d99b917">operator&gt;</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making &gt; from &lt;. <br/></td></tr>
<tr class="separator:a2c8fa4b3b83567aa2c94df6a8d99b917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4e357df8e58961b3f17181089e8f73"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b4e357df8e58961b3f17181089e8f73"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b4e357df8e58961b3f17181089e8f73"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1b4e357df8e58961b3f17181089e8f73">operator&lt;=</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a1b4e357df8e58961b3f17181089e8f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making &lt;= from &lt; and ==. <br/></td></tr>
<tr class="separator:a1b4e357df8e58961b3f17181089e8f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e06d2408bfd0dfef28bb8595445689"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29e06d2408bfd0dfef28bb8595445689"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29e06d2408bfd0dfef28bb8595445689"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a29e06d2408bfd0dfef28bb8595445689">operator&gt;=</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a29e06d2408bfd0dfef28bb8595445689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of making &gt;= from &lt; and ==. <br/></td></tr>
<tr class="separator:a29e06d2408bfd0dfef28bb8595445689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be96ec90ba71c75bd3e74ee7be0789"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68be96ec90ba71c75bd3e74ee7be0789"></a>
template&lt;typename TSmall , typename TBig &gt; </td></tr>
<tr class="memitem:a68be96ec90ba71c75bd3e74ee7be0789"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a68be96ec90ba71c75bd3e74ee7be0789">pack_type</a> (TSmall s, TBig &amp;b)</td></tr>
<tr class="memdesc:a68be96ec90ba71c75bd3e74ee7be0789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs <code>s</code> multiple times into <code>b</code>. Useful for loop unrolling. <br/></td></tr>
<tr class="separator:a68be96ec90ba71c75bd3e74ee7be0789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e8e74e1e3038d1c8a590d0470087a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04e8e74e1e3038d1c8a590d0470087a9"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a04e8e74e1e3038d1c8a590d0470087a9"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a04e8e74e1e3038d1c8a590d0470087a9">DivRU</a> (T1 n1, T2 n2)</td></tr>
<tr class="memdesc:a04e8e74e1e3038d1c8a590d0470087a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>n1</code> by <code>n2</code> and rounds the result up. This is in contrast to regular division, which rounds down. <br/></td></tr>
<tr class="separator:a04e8e74e1e3038d1c8a590d0470087a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaa1a42d5fe2c94be68a65629069449"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eaa1a42d5fe2c94be68a65629069449"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a5eaa1a42d5fe2c94be68a65629069449">TestAndSet</a> (int *pm)</td></tr>
<tr class="memdesc:a5eaa1a42d5fe2c94be68a65629069449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contents of <code>pm</code> to 1 and returns true if the previous value was 0. <br/></td></tr>
<tr class="separator:a5eaa1a42d5fe2c94be68a65629069449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1684fbc1aa083aab0bbc4c4978b7b3b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1684fbc1aa083aab0bbc4c4978b7b3b5"></a>
uoff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a1684fbc1aa083aab0bbc4c4978b7b3b5">FirstBit</a> (uint32_t v, uoff_t nbv)</td></tr>
<tr class="memdesc:a1684fbc1aa083aab0bbc4c4978b7b3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in <code>v</code> or <code>nbv</code> if none. <br/></td></tr>
<tr class="separator:a1684fbc1aa083aab0bbc4c4978b7b3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85ebb56453778aaebdcfc1c26879ddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa85ebb56453778aaebdcfc1c26879ddc"></a>
uoff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#aa85ebb56453778aaebdcfc1c26879ddc">FirstBit</a> (uint64_t v, uoff_t nbv)</td></tr>
<tr class="memdesc:aa85ebb56453778aaebdcfc1c26879ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in <code>v</code> or <code>nbv</code> if none. <br/></td></tr>
<tr class="separator:aa85ebb56453778aaebdcfc1c26879ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8cf73394e5fbf1b6b03de315334403"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#abb8cf73394e5fbf1b6b03de315334403">NextPow2</a> (uint32_t v)</td></tr>
<tr class="separator:abb8cf73394e5fbf1b6b03de315334403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3255777c7527ce6d776aa0f52707a7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3255777c7527ce6d776aa0f52707a7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3255777c7527ce6d776aa0f52707a7a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#ac3255777c7527ce6d776aa0f52707a7a">Rol</a> (T v, size_t n)</td></tr>
<tr class="memdesc:ac3255777c7527ce6d776aa0f52707a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise rotate value left. <br/></td></tr>
<tr class="separator:ac3255777c7527ce6d776aa0f52707a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741af4fabf6753b7cf205e82924e18f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a741af4fabf6753b7cf205e82924e18f4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a741af4fabf6753b7cf205e82924e18f4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a741af4fabf6753b7cf205e82924e18f4">Ror</a> (T v, size_t n)</td></tr>
<tr class="memdesc:a741af4fabf6753b7cf205e82924e18f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise rotate value right. <br/></td></tr>
<tr class="separator:a741af4fabf6753b7cf205e82924e18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfff1e222dd08016ec1a1f788b2cea8"><td class="memTemplParams" colspan="2">template&lt;typename DEST , typename SRC &gt; </td></tr>
<tr class="memitem:afdfff1e222dd08016ec1a1f788b2cea8"><td class="memTemplItemLeft" align="right" valign="top">DEST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceustl.html#afdfff1e222dd08016ec1a1f788b2cea8">noalias</a> (const DEST &amp;, SRC *s)</td></tr>
<tr class="memdesc:afdfff1e222dd08016ec1a1f788b2cea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template is to be used for dereferencing a type-punned pointer without a warning.  <a href="#afdfff1e222dd08016ec1a1f788b2cea8">More...</a><br/></td></tr>
<tr class="separator:afdfff1e222dd08016ec1a1f788b2cea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3504e47b7842e670e5966fc0248c10f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3504e47b7842e670e5966fc0248c10f1"></a>
template&lt;typename DEST , typename SRC &gt; </td></tr>
<tr class="memitem:a3504e47b7842e670e5966fc0248c10f1"><td class="memTemplItemLeft" align="right" valign="top">DEST&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noalias_cast</b> (SRC s)</td></tr>
<tr class="separator:a3504e47b7842e670e5966fc0248c10f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aedee15ab8b8508aede3759e8483cc98a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedee15ab8b8508aede3759e8483cc98a"></a>
<a class="el" href="classustl_1_1ifstream.html">ifstream</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cin</b> (STDIN_FILENO)</td></tr>
<tr class="separator:aedee15ab8b8508aede3759e8483cc98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa66e7e41f0ac88a4fdfde8b46f705e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aa66e7e41f0ac88a4fdfde8b46f705e"></a>
<a class="el" href="classustl_1_1ofstream.html">ofstream</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cout</b> (STDOUT_FILENO)</td></tr>
<tr class="separator:a3aa66e7e41f0ac88a4fdfde8b46f705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92694ba907e62bb415c8b68e01aa5422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92694ba907e62bb415c8b68e01aa5422"></a>
<a class="el" href="classustl_1_1ofstream.html">ofstream</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cerr</b> (STDERR_FILENO)</td></tr>
<tr class="separator:a92694ba907e62bb415c8b68e01aa5422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51bc3a56b006dcf640f5462f1037608"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab51bc3a56b006dcf640f5462f1037608"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>_FmtPrtChr</b> [2][8] ={&quot;'%c'&quot;,&quot;%d&quot;}</td></tr>
<tr class="separator:ab51bc3a56b006dcf640f5462f1037608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81122e5e91ea24446fb82c6d77be55a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81122e5e91ea24446fb82c6d77be55a6"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a81122e5e91ea24446fb82c6d77be55a6">endl</a> = '\n'</td></tr>
<tr class="memdesc:a81122e5e91ea24446fb82c6d77be55a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of line character. <br/></td></tr>
<tr class="separator:a81122e5e91ea24446fb82c6d77be55a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796a6092c311a9498261aedbde552fa5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a796a6092c311a9498261aedbde552fa5"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a796a6092c311a9498261aedbde552fa5">ends</a> = '\0'</td></tr>
<tr class="memdesc:a796a6092c311a9498261aedbde552fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of string character. <br/></td></tr>
<tr class="separator:a796a6092c311a9498261aedbde552fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d6efc2a8cb78ea9401b50e04b363fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12d6efc2a8cb78ea9401b50e04b363fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>T</b></td></tr>
<tr class="separator:a12d6efc2a8cb78ea9401b50e04b363fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1fe2e2b3e6642ea3c2439594fb96df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba1fe2e2b3e6642ea3c2439594fb96df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>N</b></td></tr>
<tr class="separator:aba1fe2e2b3e6642ea3c2439594fb96df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1660fbafffddb5b06253d05b6df760"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a1660fbafffddb5b06253d05b6df760"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceustl.html#a8a1660fbafffddb5b06253d05b6df760">c_DefaultAlignment</a> = __alignof__(void*)</td></tr>
<tr class="memdesc:a8a1660fbafffddb5b06253d05b6df760"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alignment performed by default. <br/></td></tr>
<tr class="separator:a8a1660fbafffddb5b06253d05b6df760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The ustl namespace contains all ustl classes and algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab198744282029c86a91a104fcf2d41a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::convert_to_bitstring </td>
          <td>(</td>
          <td class="paramtype">const bitset_value_type *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies bits from <code>v</code> of size <code>n</code> into <code>buf</code> as MSB "1011001..." LSB If <code>buf</code> is too small, MSB bits will be truncated. </p>

<p>Referenced by <a class="el" href="classustl_1_1bitset.html#a74225fe11f91eaa17f6fae197f440046">ustl::bitset&lt; Size &gt;::to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a988861257997d375e656346ca308e512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ustl::demangle_type_name </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pdmSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses C++ ABI call, if available to demangle the contents of <code>buf</code>. </p>
<p>The result is written to <code>buf</code>, with the maximum size of <code>bufSize</code>, and is zero-terminated. The return value is <code>buf</code>. </p>

<p>References <a class="el" href="namespaceustl.html#a97e712dd6676c1b2a805c05cc412484f">min()</a>, and <a class="el" href="uutility_8h.html#a1e713d3c4a1de5b99a005eac036f42de">VectorSize</a>.</p>

<p>Referenced by <a class="el" href="classustl_1_1stream__bounds__exception.html#ad0c9f1390593d99f4afda94d7b0aa829">ustl::stream_bounds_exception::info()</a>.</p>

</div>
</div>
<a class="anchor" id="abb8cf73394e5fbf1b6b03de315334403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ustl::NextPow2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next power of 2 &gt;= <code>v</code>. Values larger than UINT32_MAX/2 will return 2^0 </p>

<p>References <a class="el" href="uutility_8h.html#a6ba1ede6ce131203d657d4afc0665f6a">BitsInType</a>, and <a class="el" href="namespaceustl.html#a1684fbc1aa083aab0bbc4c4978b7b3b5">FirstBit()</a>.</p>

<p>Referenced by <a class="el" href="classustl_1_1memblock.html#a15a9c534155b48de96d44330f6f98ca3">ustl::memblock::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="afdfff1e222dd08016ec1a1f788b2cea8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DEST , typename SRC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEST ustl::noalias </td>
          <td>(</td>
          <td class="paramtype">const DEST &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SRC *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This template is to be used for dereferencing a type-punned pointer without a warning. </p>
<p>When casting a local variable to an unrelated type through a pointer (for example, casting a float to a uint32_t without conversion), the resulting memory location can be accessed through either pointer, which violates the strict aliasing rule. While -fno-strict-aliasing option can be given to the compiler, eliminating this warning, inefficient code may result in some instances, because aliasing inhibits some optimizations. By using this template, and by ensuring the memory is accessed in one way only, efficient code can be produced without the warning. For gcc 4.1.0+. </p>

</div>
</div>
<a class="anchor" id="a3027a7a3b5399a18f922c19dcef6199e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container::iterator ustl::unconst </td>
          <td>(</td>
          <td class="paramtype">typename Container::const_iterator&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the given const_iterator into an iterator. </p>

</div>
</div>
</div><!-- contents -->
<hr>
<address style="align: right;">
<small>
    Generated on Sat Nov 9 2013 13:57:32 for uSTL by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.5
</small>
</address>
</body>
</html>
