<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Raw Storage Algorithms</title>
    <link href="../default.css" rel="stylesheet" type="text/css" />
    <link href="../ustlstyle.css" rel="stylesheet" type="text/css" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="API and usage description for uSTL, a size-optimized STL implementation" />
    <meta name="Keywords" content="C++, STL, template, bloat, optimization" />
</head>
<body>
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Raw Storage Algorithms<div class="ingroups"><a class="el" href="group__Algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__MutatingAlgorithms.html">Mutating Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga023504bf8ae443671cb9ac78f088c7af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga023504bf8ae443671cb9ac78f088c7af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga023504bf8ae443671cb9ac78f088c7af">get_temporary_buffer</a>(size,  ptype)&#160;&#160;&#160;make_temporary_buffer (alloca(size_of_elements(size, ptype)), size, ptype)</td></tr>
<tr class="memdesc:ga023504bf8ae443671cb9ac78f088c7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a temporary buffer, if possible. <br /></td></tr>
<tr class="separator:ga023504bf8ae443671cb9ac78f088c7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga87362eebe1278ce1cb7f211cb0a38b74"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga87362eebe1278ce1cb7f211cb0a38b74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga87362eebe1278ce1cb7f211cb0a38b74">ustl::construct</a> (T *p)</td></tr>
<tr class="separator:ga87362eebe1278ce1cb7f211cb0a38b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4df3bc5e05e96ba205eeba18e491e0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gaca4df3bc5e05e96ba205eeba18e491e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#gaca4df3bc5e05e96ba205eeba18e491e0">ustl::construct</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:gaca4df3bc5e05e96ba205eeba18e491e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876c801a542e93ba774df2cf7f5d23d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga876c801a542e93ba774df2cf7f5d23d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga876c801a542e93ba774df2cf7f5d23d4">ustl::construct</a> (T *p, const T &amp;value)</td></tr>
<tr class="separator:ga876c801a542e93ba774df2cf7f5d23d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36114a168a2c1c06ab0034c289005d9a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36114a168a2c1c06ab0034c289005d9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga36114a168a2c1c06ab0034c289005d9a">ustl::destroy</a> (T *p) noexcept</td></tr>
<tr class="separator:ga36114a168a2c1c06ab0034c289005d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61fa049e4c1ccc5e90f215ff2f5f883e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga61fa049e4c1ccc5e90f215ff2f5f883e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga61fa049e4c1ccc5e90f215ff2f5f883e">ustl::destroy</a> (ForwardIterator first, ForwardIterator last) noexcept</td></tr>
<tr class="separator:ga61fa049e4c1ccc5e90f215ff2f5f883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a829166d43a2c5d0ee311730d9c741d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7a829166d43a2c5d0ee311730d9c741d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7a829166d43a2c5d0ee311730d9c741d"><td class="memTemplItemLeft" align="right" valign="top">pair&lt; T *, ptrdiff_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga7a829166d43a2c5d0ee311730d9c741d">ustl::make_temporary_buffer</a> (void *p, size_t n, const T *ptype)</td></tr>
<tr class="memdesc:ga7a829166d43a2c5d0ee311730d9c741d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary buffer pair from <code>p</code> and <code>n</code> This is intended to be used with alloca to create temporary buffers. The size in the returned pair is set to 0 if the allocation is unsuccessful. <br /></td></tr>
<tr class="separator:ga7a829166d43a2c5d0ee311730d9c741d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace908f3dbe46fb3e396f7abc2278a749"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gace908f3dbe46fb3e396f7abc2278a749"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#gace908f3dbe46fb3e396f7abc2278a749">ustl::uninitialized_copy</a> (InputIterator first, InputIterator last, ForwardIterator result)</td></tr>
<tr class="separator:gace908f3dbe46fb3e396f7abc2278a749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5b5c8751d738f522af3c888baad95a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga1b5b5c8751d738f522af3c888baad95a"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga1b5b5c8751d738f522af3c888baad95a">ustl::uninitialized_copy_n</a> (InputIterator first, size_t n, ForwardIterator result)</td></tr>
<tr class="separator:ga1b5b5c8751d738f522af3c888baad95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ffea658d144887202d59de54cbcb59"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga21ffea658d144887202d59de54cbcb59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga21ffea658d144887202d59de54cbcb59">ustl::uninitialized_fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;v)</td></tr>
<tr class="separator:ga21ffea658d144887202d59de54cbcb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bff8c10b2537716593c2aa963e2016"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga00bff8c10b2537716593c2aa963e2016"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RawStorageAlgorithms.html#ga00bff8c10b2537716593c2aa963e2016">ustl::uninitialized_fill_n</a> (ForwardIterator first, size_t n, const T &amp;v)</td></tr>
<tr class="separator:ga00bff8c10b2537716593c2aa963e2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms for manipulating unstructured memory. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga87362eebe1278ce1cb7f211cb0a38b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::construct </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the placement new on <code>p</code>. </p>

<p>Referenced by <a class="el" href="group__RawStorageAlgorithms.html#gaca4df3bc5e05e96ba205eeba18e491e0">ustl::construct()</a>, <a class="el" href="classustl_1_1vector.html#aee2dbfd4feaf607bfff52501193e0ec3">ustl::vector&lt; T &gt;::insert()</a>, <a class="el" href="classustl_1_1vector.html#a677ae7b942029217cff6d6a092b6296c">ustl::vector&lt; T &gt;::insert_space()</a>, <a class="el" href="classustl_1_1vector.html#acde08ada2237d7bf7a55c50f2f6ee728">ustl::vector&lt; T &gt;::push_back()</a>, <a class="el" href="classustl_1_1vector.html#a6365d0573c2607551af21295b4fceff3">ustl::vector&lt; T &gt;::resize()</a>, <a class="el" href="group__RawStorageAlgorithms.html#gace908f3dbe46fb3e396f7abc2278a749">ustl::uninitialized_copy()</a>, <a class="el" href="group__RawStorageAlgorithms.html#ga1b5b5c8751d738f522af3c888baad95a">ustl::uninitialized_copy_n()</a>, <a class="el" href="group__RawStorageAlgorithms.html#ga21ffea658d144887202d59de54cbcb59">ustl::uninitialized_fill()</a>, and <a class="el" href="group__RawStorageAlgorithms.html#ga00bff8c10b2537716593c2aa963e2016">ustl::uninitialized_fill_n()</a>.</p>

</div>
</div>
<a class="anchor" id="gaca4df3bc5e05e96ba205eeba18e491e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::construct </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the placement new on <code>p</code>. </p>

<p>References <a class="el" href="group__RawStorageAlgorithms.html#ga87362eebe1278ce1cb7f211cb0a38b74">ustl::construct()</a>, <a class="el" href="namespaceustl.html#aa3f6c55519656f92212f72aec9916c03">ustl::distance()</a>, and <a class="el" href="namespaceustl.html#a7c31c98136c275966fbd8e24e23ae1f7">ustl::max()</a>.</p>

</div>
</div>
<a class="anchor" id="ga876c801a542e93ba774df2cf7f5d23d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::construct </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the placement new on <code>p</code>. </p>

</div>
</div>
<a class="anchor" id="ga36114a168a2c1c06ab0034c289005d9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::destroy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the destructor of <code>p</code> without calling delete. </p>

<p>Referenced by <a class="el" href="classustl_1_1vector.html#af58ea8d8341238e3a83da347da7179eb">ustl::vector&lt; T &gt;::deallocate()</a>, <a class="el" href="classustl_1_1vector.html#a85ed10f88661190cebbdc28f31b7dbbc">ustl::vector&lt; T &gt;::erase()</a>, <a class="el" href="classustl_1_1vector.html#a6365d0573c2607551af21295b4fceff3">ustl::vector&lt; T &gt;::resize()</a>, and <a class="el" href="classustl_1_1vector.html#abb73b249574326267ae7ff3f10b06e48">ustl::vector&lt; T &gt;::~vector()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61fa049e4c1ccc5e90f215ff2f5f883e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::destroy </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the destructor on elements in range [first, last) without calling delete. </p>

</div>
</div>
<a class="anchor" id="gace908f3dbe46fb3e396f7abc2278a749"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::uninitialized_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies [first, last) into result by calling copy constructors in result. </p>

<p>References <a class="el" href="group__RawStorageAlgorithms.html#ga87362eebe1278ce1cb7f211cb0a38b74">ustl::construct()</a>.</p>

<p>Referenced by <a class="el" href="classustl_1_1vector.html#ad8c80a45d4909d1a258bea48995f2865">ustl::vector&lt; T &gt;::insert()</a>, and <a class="el" href="classustl_1_1vector.html#af1b4033f421cf483941895f6d7bb5664">ustl::vector&lt; T &gt;::vector()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b5b5c8751d738f522af3c888baad95a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::uninitialized_copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies [first, first + n) into result by calling copy constructors in result. </p>

<p>References <a class="el" href="group__RawStorageAlgorithms.html#ga87362eebe1278ce1cb7f211cb0a38b74">ustl::construct()</a>.</p>

<p>Referenced by <a class="el" href="classustl_1_1vector.html#a20e88bb5dfca0dfa98a53a916ea4a40d">ustl::vector&lt; T &gt;::vector()</a>.</p>

</div>
</div>
<a class="anchor" id="ga21ffea658d144887202d59de54cbcb59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ustl::uninitialized_fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls construct on all elements in [first, last) with value <code>v</code>. </p>

<p>References <a class="el" href="group__RawStorageAlgorithms.html#ga87362eebe1278ce1cb7f211cb0a38b74">ustl::construct()</a>.</p>

</div>
</div>
<a class="anchor" id="ga00bff8c10b2537716593c2aa963e2016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::uninitialized_fill_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls construct on all elements in [first, first + n) with value <code>v</code>. </p>

<p>References <a class="el" href="group__RawStorageAlgorithms.html#ga87362eebe1278ce1cb7f211cb0a38b74">ustl::construct()</a>.</p>

<p>Referenced by <a class="el" href="classustl_1_1vector.html#ac8b8b70c1ee5275c4529f7ba53d32ec4">ustl::vector&lt; T &gt;::insert()</a>, and <a class="el" href="classustl_1_1vector.html#a602df2572426d8e10860a82062f97a64">ustl::vector&lt; T &gt;::vector()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<address style="align: right;">
<small>
    Generated on Mon Sep 28 2015 17:58:50 for uSTL by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.10
</small>
</address>
</body>
</html>
