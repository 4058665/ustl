<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Predicate Algorithms</title>
    <link href="../style/default.css" rel="stylesheet" type="text/css" />
    <link href="../style/ustlstyle.css" rel="stylesheet" type="text/css" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="API and usage description for uSTL, a size-optimized STL implementation" />
    <meta name="Keywords" content="C++, STL, template, bloat, optimization" />
</head>
<body>
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Predicate Algorithms<div class="ingroups"><a class="el" href="group__Algorithms.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6a4516cd4b2891c8267d0a02a99d6661"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga6a4516cd4b2891c8267d0a02a99d6661"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6a4516cd4b2891c8267d0a02a99d6661">ustl::transform</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</td></tr>
<tr class="separator:ga6a4516cd4b2891c8267d0a02a99d6661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9978c496162a53db8e25ca312b75841d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga9978c496162a53db8e25ca312b75841d"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga9978c496162a53db8e25ca312b75841d">ustl::transform</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op)</td></tr>
<tr class="separator:ga9978c496162a53db8e25ca312b75841d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf224c7959d539bdcc4f0f098c355eefb"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Generator &gt; </td></tr>
<tr class="memitem:gaf224c7959d539bdcc4f0f098c355eefb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaf224c7959d539bdcc4f0f098c355eefb">ustl::generate</a> (ForwardIterator first, ForwardIterator last, Generator gen)</td></tr>
<tr class="separator:gaf224c7959d539bdcc4f0f098c355eefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4453ba28cbfa96e63ad17ffc05190ca"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename Generator &gt; </td></tr>
<tr class="memitem:gae4453ba28cbfa96e63ad17ffc05190ca"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gae4453ba28cbfa96e63ad17ffc05190ca">ustl::generate_n</a> (OutputIterator first, size_t n, Generator gen)</td></tr>
<tr class="separator:gae4453ba28cbfa96e63ad17ffc05190ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab557a24fb30ce4b746af06a983234685"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gab557a24fb30ce4b746af06a983234685"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gab557a24fb30ce4b746af06a983234685">ustl::sort</a> (RandomAccessIterator first, RandomAccessIterator last, Compare)</td></tr>
<tr class="separator:gab557a24fb30ce4b746af06a983234685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a011b3da797c0612ee26c29756fffe"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga66a011b3da797c0612ee26c29756fffe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga66a011b3da797c0612ee26c29756fffe">ustl::stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="separator:ga66a011b3da797c0612ee26c29756fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d82cdd06374a7583c61931c7af0da2a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga2d82cdd06374a7583c61931c7af0da2a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga2d82cdd06374a7583c61931c7af0da2a">ustl::copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:ga2d82cdd06374a7583c61931c7af0da2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf4cf8a14dadda237ef9dd3a1554cf2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gaacf4cf8a14dadda237ef9dd3a1554cf2"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaacf4cf8a14dadda237ef9dd3a1554cf2">ustl::find_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:gaacf4cf8a14dadda237ef9dd3a1554cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346d48aa4894f98816905f30687a2771"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga346d48aa4894f98816905f30687a2771"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga346d48aa4894f98816905f30687a2771">ustl::adjacent_find</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate p)</td></tr>
<tr class="separator:ga346d48aa4894f98816905f30687a2771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0401b8fc468f3ac943763edcf655e8fe"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga0401b8fc468f3ac943763edcf655e8fe"><td class="memTemplItemLeft" align="right" valign="top">pair&lt; InputIterator, <br class="typebreak"/>
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga0401b8fc468f3ac943763edcf655e8fe">ustl::mismatch</a> (InputIterator first1, InputIterator last1, InputIterator first2, BinaryPredicate comp)</td></tr>
<tr class="separator:ga0401b8fc468f3ac943763edcf655e8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c1b1932954a8e497aef7933d1e579f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga44c1b1932954a8e497aef7933d1e579f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga44c1b1932954a8e497aef7933d1e579f">ustl::equal</a> (InputIterator first1, InputIterator last1, InputIterator first2, BinaryPredicate comp)</td></tr>
<tr class="separator:ga44c1b1932954a8e497aef7933d1e579f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb8e059c559a49beb7e378f7302e393"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga8eb8e059c559a49beb7e378f7302e393"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga8eb8e059c559a49beb7e378f7302e393">ustl::count_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr class="separator:ga8eb8e059c559a49beb7e378f7302e393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be4f14f257892bea1de2b62c0b3e7eb"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga3be4f14f257892bea1de2b62c0b3e7eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga3be4f14f257892bea1de2b62c0b3e7eb">ustl::replace_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga3be4f14f257892bea1de2b62c0b3e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727911bd639a35693bae5323c8ad959f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga727911bd639a35693bae5323c8ad959f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga727911bd639a35693bae5323c8ad959f">ustl::replace_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>
<tr class="separator:ga727911bd639a35693bae5323c8ad959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bae5360b2a20cf93f08b7e13e05d381"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga0bae5360b2a20cf93f08b7e13e05d381"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga0bae5360b2a20cf93f08b7e13e05d381">ustl::remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:ga0bae5360b2a20cf93f08b7e13e05d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1ead56b32be0d1d96e32e309df8c1e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gaeb1ead56b32be0d1d96e32e309df8c1e"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaeb1ead56b32be0d1d96e32e309df8c1e">ustl::remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr class="separator:gaeb1ead56b32be0d1d96e32e309df8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795c5ecc643391dce42902af44c4ea47"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga795c5ecc643391dce42902af44c4ea47"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga795c5ecc643391dce42902af44c4ea47">ustl::unique_copy</a> (InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga795c5ecc643391dce42902af44c4ea47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242ed2f1914479018c8885ee8bf6becb"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga242ed2f1914479018c8885ee8bf6becb"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga242ed2f1914479018c8885ee8bf6becb">ustl::unique</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</td></tr>
<tr class="separator:ga242ed2f1914479018c8885ee8bf6becb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2a5ea22968a897e97ca4703c432985"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga6c2a5ea22968a897e97ca4703c432985"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6c2a5ea22968a897e97ca4703c432985">ustl::lower_bound</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:ga6c2a5ea22968a897e97ca4703c432985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7ddac748bd3e1f6f1580eff6cce363"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaca7ddac748bd3e1f6f1580eff6cce363"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaca7ddac748bd3e1f6f1580eff6cce363">ustl::binary_search</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:gaca7ddac748bd3e1f6f1580eff6cce363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032">ustl::upper_bound</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9dc80f99a56ac75288aff4331aea16f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gac9dc80f99a56ac75288aff4331aea16f"><td class="memTemplItemLeft" align="right" valign="top">pair&lt; ForwardIterator, <br class="typebreak"/>
ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gac9dc80f99a56ac75288aff4331aea16f">ustl::equal_range</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr class="separator:gac9dc80f99a56ac75288aff4331aea16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a41f73516ec79de898d9354e821dc8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga33a41f73516ec79de898d9354e821dc8"></a>
template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga33a41f73516ec79de898d9354e821dc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga33a41f73516ec79de898d9354e821dc8">ustl::nth_element</a> (RandomAccessIterator first, RandomAccessIterator, RandomAccessIterator last, Compare comp)</td></tr>
<tr class="memdesc:ga33a41f73516ec79de898d9354e821dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts <code>nth</code> element into its sorted position. In this implementation, the entire array is sorted. The performance difference is so small and the function use is so rare, there is no need to have code for it. <br/></td></tr>
<tr class="separator:ga33a41f73516ec79de898d9354e821dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga86388ce8fdc1bd169e3a8ee73f53dd16"></a>
template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga86388ce8fdc1bd169e3a8ee73f53dd16">ustl::search</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first subsequence [first2,last2) in [first1,last1) <br/></td></tr>
<tr class="separator:ga86388ce8fdc1bd169e3a8ee73f53dd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga32a5498df6616b7d23c60f45c1df2fb7"></a>
template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga32a5498df6616b7d23c60f45c1df2fb7">ustl::find_end</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last subsequence [first2,last2) in [first1,last1) <br/></td></tr>
<tr class="separator:ga32a5498df6616b7d23c60f45c1df2fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaecbcfd9b6437bb34583ad2ec950ad414"></a>
template&lt;typename Iterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaecbcfd9b6437bb34583ad2ec950ad414">ustl::search_n</a> (Iterator first, Iterator last, size_t count, const T &amp;value, BinaryPredicate comp)</td></tr>
<tr class="memdesc:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurence of <code>count</code> <code>values</code> in [first, last) <br/></td></tr>
<tr class="separator:gaecbcfd9b6437bb34583ad2ec950ad414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7a7e870ab3b0e6a74ad8397c0a3e40e4"></a>
template&lt;typename InputIterator , typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga7a7e870ab3b0e6a74ad8397c0a3e40e4">ustl::find_first_of</a> (InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches [first1,last1) for the first occurrence of an element from [first2,last2) <br/></td></tr>
<tr class="separator:ga7a7e870ab3b0e6a74ad8397c0a3e40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51634d6a0289343be2738141ce61760"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf51634d6a0289343be2738141ce61760"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaf51634d6a0289343be2738141ce61760"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaf51634d6a0289343be2738141ce61760">ustl::includes</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gaf51634d6a0289343be2738141ce61760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if [first2,last2) is a subset of [first1,last1) <br/></td></tr>
<tr class="separator:gaf51634d6a0289343be2738141ce61760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18fe33a30effaf461623c701a8770b51"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga18fe33a30effaf461623c701a8770b51"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga18fe33a30effaf461623c701a8770b51">ustl::set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga18fe33a30effaf461623c701a8770b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges [first1,last1) with [first2,last2)  <a href="#ga18fe33a30effaf461623c701a8770b51">More...</a><br/></td></tr>
<tr class="separator:ga18fe33a30effaf461623c701a8770b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c343a402644f4be865d97d23348a578"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6c343a402644f4be865d97d23348a578"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga6c343a402644f4be865d97d23348a578"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga6c343a402644f4be865d97d23348a578">ustl::set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga6c343a402644f4be865d97d23348a578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set containing elements shared by the given ranges. <br/></td></tr>
<tr class="separator:ga6c343a402644f4be865d97d23348a578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf12f1c23baeff1f70ff80f1cd436c6c9"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaf12f1c23baeff1f70ff80f1cd436c6c9">ustl::set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from [first1,last1) elements present in [first2,last2) <br/></td></tr>
<tr class="separator:gaf12f1c23baeff1f70ff80f1cd436c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga71951a9e5ab78fe83d062b3309b5e7be"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga71951a9e5ab78fe83d062b3309b5e7be">ustl::set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs union of sets A-B and B-A. <br/></td></tr>
<tr class="separator:ga71951a9e5ab78fe83d062b3309b5e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1c0ddb258f2f12f9377293633f6ab0b9"></a>
template&lt;typename ForwardIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga1c0ddb258f2f12f9377293633f6ab0b9">ustl::is_sorted</a> (ForwardIterator first, ForwardIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given range is sorted. <br/></td></tr>
<tr class="separator:ga1c0ddb258f2f12f9377293633f6ab0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0cc6d13188604ee1f39977e9b5e0e9e1"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga0cc6d13188604ee1f39977e9b5e0e9e1">ustl::lexicographical_compare</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two given containers like strcmp compares strings. <br/></td></tr>
<tr class="separator:ga0cc6d13188604ee1f39977e9b5e0e9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9d4585285b0b96d7f21a4923b747c2dd"></a>
template&lt;typename BidirectionalIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga9d4585285b0b96d7f21a4923b747c2dd">ustl::next_permutation</a> (BidirectionalIterator first, BidirectionalIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the next lexicographical permutation of [first,last). Returns false if no further permutations can be created. <br/></td></tr>
<tr class="separator:ga9d4585285b0b96d7f21a4923b747c2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae060c050cb83e758b79cf6e447d1b82c"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae060c050cb83e758b79cf6e447d1b82c"></a>
template&lt;typename BidirectionalIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gae060c050cb83e758b79cf6e447d1b82c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gae060c050cb83e758b79cf6e447d1b82c">ustl::prev_permutation</a> (BidirectionalIterator first, BidirectionalIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gae060c050cb83e758b79cf6e447d1b82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the previous lexicographical permutation of [first,last). Returns false if no further permutations can be created. <br/></td></tr>
<tr class="separator:gae060c050cb83e758b79cf6e447d1b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc49d8f4515858066a500225cd5d213"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4dc49d8f4515858066a500225cd5d213"></a>
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4dc49d8f4515858066a500225cd5d213"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga4dc49d8f4515858066a500225cd5d213">ustl::max_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga4dc49d8f4515858066a500225cd5d213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the max element in [first,last) <br/></td></tr>
<tr class="separator:ga4dc49d8f4515858066a500225cd5d213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae8f424b822565092533dda5b65b06d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8ae8f424b822565092533dda5b65b06d"></a>
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga8ae8f424b822565092533dda5b65b06d"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga8ae8f424b822565092533dda5b65b06d">ustl::min_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>
<tr class="memdesc:ga8ae8f424b822565092533dda5b65b06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the min element in [first,last) <br/></td></tr>
<tr class="separator:ga8ae8f424b822565092533dda5b65b06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga44ac4cdee5ab5bb32aea40cd92f6bdcd"></a>
template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga44ac4cdee5ab5bb32aea40cd92f6bdcd">ustl::partial_sort</a> (RandomAccessIterator first, RandomAccessIterator, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes [first,middle) a part of the sorted array. Contents of [middle,last) is undefined. This implementation just calls stable_sort. <br/></td></tr>
<tr class="separator:ga44ac4cdee5ab5bb32aea40cd92f6bdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaca13a8df57cfc9d9a84da2477d3f1bc0"></a>
template&lt;typename InputIterator , typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#gaca13a8df57cfc9d9a84da2477d3f1bc0">ustl::partial_sort_copy</a> (InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, StrictWeakOrdering comp)</td></tr>
<tr class="memdesc:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like partial_sort, but outputs to [result_first,result_last) <br/></td></tr>
<tr class="separator:gaca13a8df57cfc9d9a84da2477d3f1bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c63d621e94fda2bca1c215d51f2f36"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga34c63d621e94fda2bca1c215d51f2f36"></a>
template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga34c63d621e94fda2bca1c215d51f2f36"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga34c63d621e94fda2bca1c215d51f2f36">ustl::stable_partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr class="memdesc:ga34c63d621e94fda2bca1c215d51f2f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like partition, but preserves equal element order. <br/></td></tr>
<tr class="separator:ga34c63d621e94fda2bca1c215d51f2f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35be65dae1fb327c8d5e2421689dd074"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga35be65dae1fb327c8d5e2421689dd074"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PredicateAlgorithms.html#ga35be65dae1fb327c8d5e2421689dd074">ustl::partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr class="memdesc:ga35be65dae1fb327c8d5e2421689dd074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits [first,last) in two by <code>pred</code>.  <a href="#ga35be65dae1fb327c8d5e2421689dd074">More...</a><br/></td></tr>
<tr class="separator:ga35be65dae1fb327c8d5e2421689dd074"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms that take a functor object. Avoid these if you can, and carefully check the generated assembly if you can't. These algorithms can and will generate prodigious amounts of bloat if you are not very very careful about writing your functors. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga346d48aa4894f98816905f30687a2771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first iterator such that p(*i, *(i + 1)) == true. </p>

</div>
</div>
<a class="anchor" id="gaca7ddac748bd3e1f6f1580eff6cce363"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ustl::binary_search </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a binary search inside the sorted range. </p>

<p>References <a class="el" href="group__SearchingAlgorithms.html#ga721dcc2aef1faf8d2d3d6b5f1799a2ad">ustl::lower_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d82cdd06374a7583c61931c7af0da2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy_if copies elements from the range [first, last) to the range [result, result + (last - first)) if pred(*i) returns true. </p>

</div>
</div>
<a class="anchor" id="ga8eb8e059c559a49beb7e378f7302e393"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ustl::count_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count_if finds the number of elements in [first, last) that satisfy the predicate pred. More precisely, the first version of count_if returns the number of iterators i in [first, last) such that pred(*i) is true. </p>

</div>
</div>
<a class="anchor" id="ga44c1b1932954a8e497aef7933d1e579f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ustl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if two ranges are equal. This is an extension, present in uSTL and SGI STL. </p>

<p>References <a class="el" href="group__SearchingAlgorithms.html#ga3b6c1ae891e7676a06aef1eeca7c8145">ustl::mismatch()</a>.</p>

</div>
</div>
<a class="anchor" id="gac9dc80f99a56ac75288aff4331aea16f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;ForwardIterator,ForwardIterator&gt; ustl::equal_range </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pair&lt;lower_bound,upper_bound&gt; </p>

<p>References <a class="el" href="group__SearchingAlgorithms.html#ga721dcc2aef1faf8d2d3d6b5f1799a2ad">ustl::lower_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="gaacf4cf8a14dadda237ef9dd3a1554cf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InputIterator ustl::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first iterator i in the range [first, last) such that pred(*i) is true. Returns last if no such iterator exists. </p>

</div>
</div>
<a class="anchor" id="gaf224c7959d539bdcc4f0f098c355eefb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::generate </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate assigns the result of invoking gen, a function object that takes no arguments, to each element in the range [first, last). </p>

<p>Referenced by <a class="el" href="group__GeneratorAlgorithms.html#gabc667e1354cc3eb585504d92e1436069">ustl::generate()</a>.</p>

</div>
</div>
<a class="anchor" id="gae4453ba28cbfa96e63ad17ffc05190ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIterator , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::generate_n </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate_n assigns the result of invoking gen, a function object that takes no arguments, to each element in the range [first, first+n). The return value is first + n. </p>

</div>
</div>
<a class="anchor" id="ga6c2a5ea22968a897e97ca4703c432985"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::lower_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the furthermost iterator i in [first, last) such that, for every iterator j in [first, i), comp(*j, value) is true. Assumes the range is sorted. </p>

<p>References <a class="el" href="namespaceustl.html#a082b5d5dcac34db043cd212a6f830ca8">ustl::advance()</a>, and <a class="el" href="namespaceustl.html#aa3f6c55519656f92212f72aec9916c03">ustl::distance()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0401b8fc468f3ac943763edcf655e8fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;InputIterator,InputIterator&gt; ustl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the pointer to the first pair of unequal elements. </p>

<p>References <a class="el" href="namespaceustl.html#a1d390278971fa5c4a85bbd2946424ab9">ustl::make_pair()</a>.</p>

</div>
</div>
<a class="anchor" id="ga35be65dae1fb327c8d5e2421689dd074"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::partition </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits [first,last) in two by <code>pred</code>. </p>
<p>Creates two ranges [first,middle) and [middle,last), where every element in the former is less than every element in the latter. The return value is middle. </p>

<p>References <a class="el" href="group__PredicateAlgorithms.html#ga34c63d621e94fda2bca1c215d51f2f36">ustl::stable_partition()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0bae5360b2a20cf93f08b7e13e05d381"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove_copy_if copies elements from the range [first, last) to a range beginning at result, except that elements for which pred is true are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range [first, last). </p>

</div>
</div>
<a class="anchor" id="gaeb1ead56b32be0d1d96e32e309df8c1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove_if removes from the range [first, last) every element x such that pred(x) is true. That is, remove_if returns an iterator new_last such that the range [first, new_last) contains no elements for which pred is true. The iterators in the range [new_last, last) are all still dereferenceable, but the elements that they point to are unspecified. Remove_if is stable, meaning that the relative order of elements that are not removed is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gae020c456b0dcdb049c37b08bc9b87ee3">ustl::remove_copy_if()</a>.</p>

</div>
</div>
<a class="anchor" id="ga727911bd639a35693bae5323c8ad959f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename Predicate , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace_copy_if copies elements from the range [first, last) to the range [result, result + (last-first)), except that any element for which pred is true is not copied; new_value is copied instead. More precisely, for every integer n such that 0 &lt;= n &lt; last-first, replace_copy_if performs the assignment *(result+n) = new_value if pred(*(first+n)), and *(result+n) = *(first+n) otherwise. </p>

</div>
</div>
<a class="anchor" id="ga3be4f14f257892bea1de2b62c0b3e7eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Predicate , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustl::replace_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace_if replaces every element in the range [first, last) for which pred returns true with new_value. That is: for every iterator i, if pred(*i) is true then it performs the assignment *i = new_value. </p>

</div>
</div>
<a class="anchor" id="ga18fe33a30effaf461623c701a8770b51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::set_union </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges [first1,last1) with [first2,last2) </p>
<p>Result will contain every element that is in either set. If duplicate elements are present, max(n,m) is placed in the result. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gaffd931061ff91b8bc27954db50d09843">ustl::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="gab557a24fb30ce4b746af06a983234685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ustl::sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the container </p>

<p>References <a class="el" href="namespaceustl.html#aa3f6c55519656f92212f72aec9916c03">ustl::distance()</a>.</p>

<p>Referenced by <a class="el" href="group__PredicateAlgorithms.html#ga33a41f73516ec79de898d9354e821dc8">ustl::nth_element()</a>, and <a class="el" href="group__SortingAlgorithms.html#ga10efb8df16e5514a4d776b9b847b4732">ustl::sort()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66a011b3da797c0612ee26c29756fffe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ustl::stable_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the container preserving order of equal elements. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gaa28c0eb7cbd2b0665c5974e6d80e361f">ustl::rotate()</a>.</p>

<p>Referenced by <a class="el" href="group__PredicateAlgorithms.html#ga44ac4cdee5ab5bb32aea40cd92f6bdcd">ustl::partial_sort()</a>, and <a class="el" href="group__SortingAlgorithms.html#gadadad16658a8faa8eb0617f65dc132fa">ustl::stable_sort()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a4516cd4b2891c8267d0a02a99d6661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::transform </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The first version of transform performs the operation op(*i) for each iterator i in the range [first, last), and assigns the result of that operation to *o, where o is the corresponding output iterator. That is, for each n such that 0 &lt;= n &lt; last - first, it performs the assignment *(result + n) = op(*(first + n)). The return value is result + (last - first). </p>

<p>Referenced by <a class="el" href="classustl_1_1bitset.html#a26577cafe8b5054a1582232a22c85f2c">ustl::bitset&lt; Size &gt;::flip()</a>, and <a class="el" href="group__MutatingAlgorithms.html#ga0c67dd2fddca5eec86a948bfb52be4ff">ustl::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9978c496162a53db8e25ca312b75841d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::transform </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The second version of transform is very similar, except that it uses a Binary Function instead of a Unary Function: it performs the operation op(*i1, *i2) for each iterator i1 in the range [first1, last1) and assigns the result to *o, where i2 is the corresponding iterator in the second input range and where o is the corresponding output iterator. That is, for each n such that 0 &lt;= n &lt; last1 - first1, it performs the assignment *(result + n) = op(*(first1 + n), *(first2 + n). The return value is result + (last1 - first1). </p>

</div>
</div>
<a class="anchor" id="ga242ed2f1914479018c8885ee8bf6becb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Every time a consecutive group of duplicate elements appears in the range [first, last), the algorithm unique removes all but the first element. That is, unique returns an iterator new_last such that the range [first, new_last) contains no two consecutive elements that are duplicates. The iterators in the range [new_last, last) are all still dereferenceable, but the elements that they point to are unspecified. Unique is stable, meaning that the relative order of elements that are not removed is unchanged. </p>

<p>References <a class="el" href="group__MutatingAlgorithms.html#gae843d0bdce4ccf55205edb33eb3ba0d0">ustl::unique_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga795c5ecc643391dce42902af44c4ea47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ustl::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The reason there are two different versions of unique_copy is that there are two different definitions of what it means for a consecutive group of elements to be duplicates. In the first version, the test is simple equality: the elements in a range [f, l) are duplicates if, for every iterator i in the range, either i == f or else *i == *(i-1). In the second, the test is an arbitrary Binary Predicate binary_pred: the elements in [f, l) are duplicates if, for every iterator i in the range, either i == f or else binary_pred(*i, *(i-1)) is true. </p>

</div>
</div>
<a class="anchor" id="ga6f4cc3e9e48bbe8f05cb9b9d2f1f6032"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T , typename StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator ustl::upper_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the furthermost iterator i in [first,last) such that for every iterator j in [first,i), comp(value,*j) is false. </p>

<p>References <a class="el" href="namespaceustl.html#a082b5d5dcac34db043cd212a6f830ca8">ustl::advance()</a>, and <a class="el" href="namespaceustl.html#aa3f6c55519656f92212f72aec9916c03">ustl::distance()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<address style="align: right;">
<small>
    Generated on Sat Nov 9 2013 13:57:32 for uSTL by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.5
</small>
</address>
</body>
</html>
